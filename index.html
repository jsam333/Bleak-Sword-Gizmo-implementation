<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bleak Sword Gizmo Prototype</title>
  <style>
    :root {
      color-scheme: light;
    }

    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #6a6a6a;
      font-family: Arial, sans-serif;
    }

    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #6a6a6a;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    "use strict";

    const GAME_WIDTH = 500;
    const GAME_HEIGHT = 720;
    const TAU = Math.PI * 2;
    const EPSILON = 1e-7;

    const GRASS_SVG = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
      <rect width="100" height="100" fill="%237cb342"/>
      <path d="M10,20 Q15,5 20,20 Q25,5 30,20" stroke="%23689f38" stroke-width="2" fill="none"/>
      <path d="M40,50 Q45,35 50,50 Q55,35 60,50" stroke="%23558b2f" stroke-width="2" fill="none"/>
      <path d="M70,80 Q75,65 80,80 Q85,65 90,80" stroke="%23689f38" stroke-width="2" fill="none"/>
      <path d="M20,70 Q25,55 30,70 Q35,55 40,70" stroke="%238bc34a" stroke-width="2" fill="none"/>
      <path d="M80,30 Q85,15 90,30 Q95,15 100,30" stroke="%23558b2f" stroke-width="2" fill="none"/>
    </svg>`;

    const INPUT_CFG = {
      minSwipeDistance: 14,
      chargeStartDelay: 0.1,
      chargeFillDuration: 0.2,
      chargeGraceThreshold: 0.75
    };

    const PLAYER_CFG = {
      width: 10.08,
      height: 43.2,
      maxHealth: 4,
      iframeDuration: 0.5,
      hitFlashDuration: 0.3,
      dodgeDuration: 0.12,
      chargedDuration: 0.2,
      dodgeTravel: 78,
      chargedTravel: 150,
      dodgeSpin: Math.PI * 0.8,
      chargedSpin: TAU * 2,
      chargedTrailInterval: 0.0064,
      dodgeTrailInterval: 0.016,
      dodgeTrailLife: 0.32,
      chargedTrailLife: 0.44,
      dodgeTrailAlpha: 0.2,
      chargedTrailAlpha: 0.3,
      maxTrailSamples: 48,
      idleDampingRate: 18,
      shakeOnHit: { intensity: 8, duration: 0.2 },
      trailPositionThresholdSq: 0.01,
      trailAngleThreshold: 0.01
    };

    const ENEMY_CFG = {
      width: 33,
      height: 30,
      hitRadius: 18,
      maxHealthQuarters: 4,
      chargeTriggerDistance: 75,
      windupDuration: 0.57,
      chargeDuration: 0.256,
      recoverDuration: 0.3,
      postAttackCooldownDuration: 0.75,
      stalkSpeed: 36,
      chargeSpeed: 560,
      stunDuration: 0.32,
      chargeSpinAmount: TAU * 1.4,
      chargeTrailInterval: 0.016,
      chargeTrailLife: 0.34,
      chargeTrailAlpha: 0.24,
      maxTrailSamples: 36,
      recoverDampingRate: 10,
      knockbackDampingRate: 7,
      combatReachPlayerFactor: 0.38,
      hitFlashDuration: 0.09,
      hitCooldownDuration: 0.16,
      knockbackImpulse: 520,
      defaultChargeDirection: { x: 0, y: 1 }
    };

    const FX_CFG = {
      hitParticleCount: 12,
      hitParticleSpread: Math.PI * 0.8,
      hitParticleMinSpeed: 180,
      hitParticleMaxSpeed: 420,
      hitParticleMinLife: 0.15,
      hitParticleMaxLife: 0.35,
      hitParticleMinSize: 3,
      hitParticleMaxSize: 7,
      hitParticleColors: ["#ffffff", "#ffffaa", "#ffdd66"],
      hitParticleDrag: 5,
      hitRingRadius: 80,
      hitRingLife: 0.25,
      hitShake: { intensity: 6, duration: 0.15 },
      hitstopDuration: 0.05,
      hitTimeSlow: { duration: 0.3, minScale: 0.15 },
      deathShake: { intensity: 14, duration: 0.3 },
      deathHitstopDuration: 0.12,
      deathTimeSlow: { duration: 0.55, minScale: 0.06 },
      deathRingRadius: 120,
      deathRingLife: 0.4,
      deathParticleCount: 24,
      deathParticleMinSpeed: 100,
      deathParticleMaxSpeed: 350,
      deathParticleMinLife: 0.3,
      deathParticleMaxLife: 0.6,
      deathParticleMinSize: 4,
      deathParticleMaxSize: 10,
      deathParticleColors: ["#d62222", "#ff4444", "#ff8800", "#ffaa22"],
      deathParticleDrag: 3,
      rainbowMinCount: 150,
      rainbowExtraCount: 51
    };

    const UI_CFG = {
      healthBarWidth: 160,
      healthBarHeight: 10,
      healthBarBottomMargin: 24
    };

    const RAINBOW_CFG = {
      speed: 520,
      zBase: 250,
      zRand: 250,
      sizeBase: 3,
      sizeRand: 5,
      gravity: 600,
      bouncinessBase: 0.5,
      bouncinessRand: 0.2,
      drag: 1.5,
      visualYOffset: 0.7,
      scaleMult: 0.002,
      globalAlpha: 0.425
    };

    const TUTORIAL_CFG = {
      dodgeSlowMoTrigger: 0.45,
      crawlScale: 0.03,
      crawlDuration: 2.8,
      slowDropRate: 12,
      chainSpawnDelay: 0.2,
      chainSpawnCount: 3,
      waitHoldDelay: 0.2,
      freeFightDelay: 0.5
    };

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function easeOutCubic(t) {
      const invT = 1 - t;
      return 1 - (invT * invT * invT);
    }

    const ratEmojiCanvas = document.createElement("canvas");
    const ratEmojiCtx = ratEmojiCanvas.getContext("2d");
    const ratFontSize = ENEMY_CFG.height * 1.2;
    ratEmojiCanvas.width = ratFontSize * 1.5;
    ratEmojiCanvas.height = ratFontSize * 1.5;
    ratEmojiCtx.font = `${ratFontSize}px sans-serif`;
    ratEmojiCtx.textAlign = "center";
    ratEmojiCtx.textBaseline = "middle";
    ratEmojiCtx.fillText("ðŸ€", ratEmojiCanvas.width / 2, ratEmojiCanvas.height / 2);

    class MathUtils {
      static swapAndPop(array, index) {
        const last = array.length - 1;
        if (index !== last) {
          array[index] = array[last];
        }
        array.pop();
      }

      static distanceSq(x1, y1, x2, y2) {
        const dx = x1 - x2;
        const dy = y1 - y2;
        return dx * dx + dy * dy;
      }

      static isPointInRect(x, y, minX, minY, maxX, maxY) {
        return x >= minX && x <= maxX && y >= minY && y <= maxY;
      }

      static isCircleOverlappingRect(circleX, circleY, radius, rectMinX, rectMinY, rectMaxX, rectMaxY) {
        if (MathUtils.isPointInRect(circleX, circleY, rectMinX, rectMinY, rectMaxX, rectMaxY)) {
          return true;
        }
        const closestX = clamp(circleX, rectMinX, rectMaxX);
        const closestY = clamp(circleY, rectMinY, rectMaxY);
        return MathUtils.distanceSq(circleX, circleY, closestX, closestY) <= radius * radius;
      }
    }

    class Vec2 {
      static add(a, b) {
        return { x: a.x + b.x, y: a.y + b.y };
      }

      static sub(a, b) {
        return { x: a.x - b.x, y: a.y - b.y };
      }

      static mul(a, scalar) {
        return { x: a.x * scalar, y: a.y * scalar };
      }

      static length(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      }

      static normalize(v) {
        const len = Vec2.length(v);
        if (len <= EPSILON) {
          return { x: 0, y: 0 };
        }
        return { x: v.x / len, y: v.y / len };
      }
    }

    function hslToRgb(h, s, l) {
      s /= 100;
      l /= 100;
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = l - c / 2;
      let r, g, b;
      if (h < 60) { r = c; g = x; b = 0; }
      else if (h < 120) { r = x; g = c; b = 0; }
      else if (h < 180) { r = 0; g = c; b = x; }
      else if (h < 240) { r = 0; g = x; b = c; }
      else if (h < 300) { r = x; g = 0; b = c; }
      else { r = c; g = 0; b = x; }
      return {
        r: Math.round((r + m) * 255),
        g: Math.round((g + m) * 255),
        b: Math.round((b + m) * 255)
      };
    }

    class InputSystem {
      constructor(getWorldPointer) {
        this.getWorldPointer = getWorldPointer;
        this.activePointerId = null;
        this.down = false;
        this.start = { x: 0, y: 0 };
        this.current = { x: 0, y: 0 };
        this.holdGameDuration = 0;
        this.pendingSwipe = null;

        this.minSwipeDistance = INPUT_CFG.minSwipeDistance;
        this.chargeStartDelay = INPUT_CFG.chargeStartDelay;
        this.chargeFillDuration = INPUT_CFG.chargeFillDuration;
        this.fullChargeThreshold = this.chargeStartDelay + this.chargeFillDuration;
        this.chargeGraceThreshold = INPUT_CFG.chargeGraceThreshold;
      }

      bind(canvas) {
        canvas.addEventListener("pointerdown", (event) => this.onPointerDown(event));
        canvas.addEventListener("pointermove", (event) => this.onPointerMove(event));
        canvas.addEventListener("pointerup", (event) => this.onPointerUp(event));
        canvas.addEventListener("pointercancel", (event) => this.onPointerUp(event));
      }

      isInPlayfield(point) {
        return point.x >= 0 && point.x <= GAME_WIDTH && point.y >= 0 && point.y <= GAME_HEIGHT;
      }

      onPointerDown(event) {
        if (this.down) {
          return;
        }

        const world = this.getWorldPointer(event);
        if (!world || !this.isInPlayfield(world)) {
          return;
        }

        this.down = true;
        this.activePointerId = event.pointerId;
        this.start = world;
        this.current = world;
        this.holdGameDuration = 0;
        this.pendingSwipe = null;
      }

      onPointerMove(event) {
        if (!this.down || event.pointerId !== this.activePointerId) {
          return;
        }
        const world = this.getWorldPointer(event);
        if (!world) {
          return;
        }
        this.current = world;
      }

      onPointerUp(event) {
        if (!this.down || event.pointerId !== this.activePointerId) {
          return;
        }

        const world = this.getWorldPointer(event);
        const releasePos = world || this.current;
        const holdDuration = this.holdGameDuration;
        const swipeVec = Vec2.sub(releasePos, this.start);
        const swipeDistance = Vec2.length(swipeVec);

        if (swipeDistance >= this.minSwipeDistance) {
          const chargeAtRelease = holdDuration < this.chargeStartDelay ? 0
            : clamp((holdDuration - this.chargeStartDelay) / this.chargeFillDuration, 0, 1);
          this.pendingSwipe = {
            direction: Vec2.normalize(swipeVec),
            distance: swipeDistance,
            holdDuration,
            fullyCharged: chargeAtRelease >= this.chargeGraceThreshold
          };
        }

        this.down = false;
        this.activePointerId = null;
      }

      advanceHold(dt) {
        if (!this.down) {
          return;
        }
        this.holdGameDuration += dt;
      }

      consumeSwipe() {
        const swipe = this.pendingSwipe;
        this.pendingSwipe = null;
        return swipe;
      }

      getHoldDuration(nowSeconds) {
        if (!this.down) {
          return 0;
        }
        return this.holdGameDuration;
      }

      getChargeProgress(nowSeconds) {
        const hold = this.getHoldDuration(nowSeconds);
        if (hold < this.chargeStartDelay) {
          return 0;
        }
        return clamp((hold - this.chargeStartDelay) / this.chargeFillDuration, 0, 1);
      }
    }

    class Entity {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.width = width;
        this.height = height;
        this.trail = [];
        this.trailSpawnTimer = 0;
      }

      clampToPlayfield() {
        const halfW = this.width * 0.5;
        const halfH = this.height * 0.5;
        this.x = clamp(this.x, halfW, GAME_WIDTH - halfW);
        this.y = clamp(this.y, halfH, GAME_HEIGHT - halfH);
      }

      ageTrail(dt) {
        for (let i = this.trail.length - 1; i >= 0; i -= 1) {
          const sample = this.trail[i];
          sample.age += dt;
          if (sample.age >= sample.life) {
            MathUtils.swapAndPop(this.trail, i);
          }
        }
      }
    }

    class Player extends Entity {
      constructor() {
        super(GAME_WIDTH * 0.5, GAME_HEIGHT * 0.5, PLAYER_CFG.width, PLAYER_CFG.height);
        this.baseAngle = 0;
        this.spinAngle = 0;

        this.action = null;
        this.actionSerial = 0;
        this.stains = [];

        this.chargeProgress = 0;
        this.chargeVisible = false;

        this.maxHealth = PLAYER_CFG.maxHealth;
        this.health = this.maxHealth;
        this.iframeDuration = PLAYER_CFG.iframeDuration;
        this.iframeTimer = 0;
        this.hitFlashTimer = 0;
      }

      startMove(type, direction) {
        const dir = Vec2.normalize(direction);
        const horizontalSign = dir.x >= 0 ? 1 : -1;

        const isDodge = type === "dodge";
        const duration = isDodge ? PLAYER_CFG.dodgeDuration : PLAYER_CFG.chargedDuration;
        const travel = isDodge ? PLAYER_CFG.dodgeTravel : PLAYER_CFG.chargedTravel;
        const spins = isDodge ? PLAYER_CFG.dodgeSpin * horizontalSign : PLAYER_CFG.chargedSpin * horizontalSign;
        this.actionSerial += 1;

        this.action = {
          id: this.actionSerial,
          type,
          direction: dir,
          duration,
          elapsed: 0,
          travel,
          spins,
          startAngle: 0,
          prevTravelT: 0
        };
      }

      takeDamage(game) {
        if (this.iframeTimer > 0 || this.health <= 0) return;
        this.health = Math.max(0, this.health - 1);
        this.iframeTimer = this.iframeDuration;
        this.hitFlashTimer = PLAYER_CFG.hitFlashDuration;
        game.triggerShake(PLAYER_CFG.shakeOnHit.intensity, PLAYER_CFG.shakeOnHit.duration);
      }

      update(dt, input, nowSeconds) {
        this.updateStatusTimers(dt);
        const holdDuration = input.getHoldDuration(nowSeconds);
        this.chargeVisible = input.down && holdDuration >= input.chargeStartDelay;
        this.chargeProgress = input.getChargeProgress(nowSeconds);
        this.consumeQueuedSwipe(input);
        this.updateAction(dt);
        this.applyPostActionDamping(dt);
        this.applyMovement(dt);
        this.clampToPlayfield();
        this.ageTrail(dt);
      }

      updateStatusTimers(dt) {
        this.iframeTimer = Math.max(0, this.iframeTimer - dt);
        this.hitFlashTimer = Math.max(0, this.hitFlashTimer - dt);
      }

      consumeQueuedSwipe(input) {
        const swipe = input.consumeSwipe();
        if (swipe) {
          const type = swipe.fullyCharged ? "charged" : "dodge";
          this.startMove(type, swipe.direction);
        }
      }

      updateAction(dt) {
        if (this.action) {
          const frameStartX = this.x;
          const frameStartY = this.y;
          const frameStartAngle = this.spinAngle;
          this.action.elapsed += dt;
          const t = clamp(this.action.elapsed / this.action.duration, 0, 1);
          if (this.action.type === "charged") {
            const travelT = easeOutCubic(t);
            const deltaTravel = (travelT - this.action.prevTravelT) * this.action.travel;
            this.action.prevTravelT = travelT;
            const moveX = this.action.direction.x * deltaTravel;
            const moveY = this.action.direction.y * deltaTravel;
            this.x += moveX;
            this.y += moveY;
            if (dt > EPSILON) {
              this.vx = moveX / dt;
              this.vy = moveY / dt;
            } else {
              this.vx = 0;
              this.vy = 0;
            }
          } else {
            const speed = this.action.travel / this.action.duration;
            this.vx = this.action.direction.x * speed;
            this.vy = this.action.direction.y * speed;
          }
          this.spinAngle = this.action.startAngle + this.action.spins * easeOutCubic(t);

          const trailInterval = this.action.type === "charged"
            ? PLAYER_CFG.chargedTrailInterval
            : PLAYER_CFG.dodgeTrailInterval;
          this.trailSpawnTimer += dt;
          while (this.trailSpawnTimer >= trailInterval) {
            const sampleTimeInFrame = dt - (this.trailSpawnTimer - trailInterval);
            const sampleT = dt > EPSILON ? clamp(sampleTimeInFrame / dt, 0, 1) : 1;
            const sampleX = frameStartX + (this.x - frameStartX) * sampleT;
            const sampleY = frameStartY + (this.y - frameStartY) * sampleT;
            const sampleAngle = frameStartAngle + (this.spinAngle - frameStartAngle) * sampleT;
            this.trailSpawnTimer -= trailInterval;
            const prev = this.trail[this.trail.length - 1];
            if (prev) {
              const dx = prev.x - sampleX;
              const dy = prev.y - sampleY;
              const da = Math.abs(prev.angle - sampleAngle);
              if (dx * dx + dy * dy < PLAYER_CFG.trailPositionThresholdSq && da < PLAYER_CFG.trailAngleThreshold) {
                continue;
              }
            }
            this.trail.push({
              x: sampleX,
              y: sampleY,
              angle: sampleAngle,
              age: 0,
              life: this.action.type === "dodge" ? PLAYER_CFG.dodgeTrailLife : PLAYER_CFG.chargedTrailLife,
              alpha: this.action.type === "dodge" ? PLAYER_CFG.dodgeTrailAlpha : PLAYER_CFG.chargedTrailAlpha
            });
            if (this.trail.length > PLAYER_CFG.maxTrailSamples) {
              this.trail.shift();
            }
          }

          if (this.action.elapsed >= this.action.duration) {
            this.action = null;
            this.vx = 0;
            this.vy = 0;
            this.spinAngle = 0;
          }
        }
      }

      applyPostActionDamping(dt) {
        if (this.action) {
          return;
        }
        this.vx *= Math.max(0, 1 - dt * PLAYER_CFG.idleDampingRate);
        this.vy *= Math.max(0, 1 - dt * PLAYER_CFG.idleDampingRate);
        this.spinAngle = 0;
      }

      applyMovement(dt) {
        if (!this.action || this.action.type !== "charged") {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
        }
      }

      draw(ctx) {
        ctx.save();
        ctx.fillStyle = "#ffffff";
        for (let i = 0; i < this.trail.length; i += 1) {
          const t = this.trail[i];
          const alpha = (1 - t.age / t.life) * t.alpha;
          ctx.globalAlpha = alpha;
          ctx.translate(t.x, t.y);
          ctx.rotate(t.angle);
          ctx.fillRect(-this.width * 0.5, -this.height * 0.5, this.width, this.height);
          ctx.rotate(-t.angle);
          ctx.translate(-t.x, -t.y);
        }
        ctx.restore();

        if (this.action && this.action.type === "charged") {
          const ringScale = 1.1;
          const ringLineWidth = 5 * ringScale * 1.3;
          const ringOuterRadius = this.height * 0.5 * ringScale;
          const ringRadius = ringOuterRadius - ringLineWidth * 0.5;
          ctx.save();
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = ringLineWidth;
          ctx.beginPath();
          ctx.arc(this.x, this.y, ringRadius, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }

        const shadowY = this.y + this.height * 0.5 + 1.5;
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.14)";
        ctx.beginPath();
        ctx.ellipse(this.x, shadowY, this.width * 0.56, 2.2, 0, 0, TAU);
        ctx.fill();
        ctx.fillStyle = "rgba(0, 0, 0, 0.07)";
        ctx.beginPath();
        ctx.ellipse(this.x, shadowY + 0.2, this.width * 0.78, 3.3, 0, 0, TAU);
        ctx.fill();
        ctx.restore();

        if (this.hitFlashTimer > 0 && Math.sin(performance.now() * 0.03) > 0) {
          return;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.spinAngle);
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 1;
        ctx.strokeRect(-this.width * 0.5 - 1.5, -this.height * 0.5 - 1.5, this.width + 3, this.height + 3);
        ctx.restore();

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.spinAngle);
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(-this.width * 0.5, -this.height * 0.5, this.width, this.height);
        if (this.stains.length > 0) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(-this.width * 0.5, -this.height * 0.5, this.width, this.height);
          ctx.clip();
          for (let i = 0; i < this.stains.length; i++) {
            const s = this.stains[i];
            ctx.globalAlpha = s.alpha;
            ctx.fillStyle = `rgb(${s.r},${s.g},${s.b})`;
            ctx.beginPath();
            ctx.arc(s.localX, s.localY, s.radius, 0, TAU);
            ctx.fill();
          }
          ctx.restore();
        }
        ctx.restore();

        if (this.chargeVisible && !this.action) {
          const ringScale = 1.1;
          const chargeBarLineWidth = 3 * 1.3;
          const chargeBarOuterRadius = this.height * 0.5 * ringScale;
          const chargeBarRadius = chargeBarOuterRadius - chargeBarLineWidth * 0.5;
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.lineWidth = chargeBarLineWidth;
          ctx.strokeStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(0, 0, chargeBarRadius, -Math.PI / 2, -Math.PI / 2 + TAU * this.chargeProgress);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    class TriangleEnemy extends Entity {
      constructor(x, y) {
        super(x, y, ENEMY_CFG.width, ENEMY_CFG.height);
        this.prevX = x;
        this.prevY = y;
        this.prevRollAngle = 0;
        this.renderX = x;
        this.renderY = y;
        this.renderRollAngle = 0;
        this.entering = false;
        this.knockbackVX = 0;
        this.knockbackVY = 0;

        this.hitRadius = ENEMY_CFG.hitRadius;

        this.maxHealthQuarters = ENEMY_CFG.maxHealthQuarters;
        this.healthQuarters = this.maxHealthQuarters;
        this.alive = true;

        this.state = "stalk";
        this.chargeTriggerDistance = ENEMY_CFG.chargeTriggerDistance;
        this.windupDuration = ENEMY_CFG.windupDuration;
        this.chargeDuration = ENEMY_CFG.chargeDuration;
        this.recoverDuration = ENEMY_CFG.recoverDuration;
        this.postAttackCooldownDuration = ENEMY_CFG.postAttackCooldownDuration;
        this.windupTimer = 0;
        this.chargeTimer = 0;
        this.recoverTimer = 0;
        this.postAttackCooldownTimer = 0;
        this.chargeDirection = { x: 0, y: 0 };

        this.stalkSpeed = ENEMY_CFG.stalkSpeed;
        this.chargeSpeed = ENEMY_CFG.chargeSpeed;
        this.waddleTime = 0;
        this.hitCooldown = 0;
        this.hitFlashTimer = 0;
        this.stunTimer = 0;
        this.stunDuration = ENEMY_CFG.stunDuration;
        this.lastHitByActionId = null;
        this.rollAngle = 0;
        this.chargeSpinAmount = ENEMY_CFG.chargeSpinAmount;
        this.chargeElapsed = 0;
      }

      update(dt, player) {
        if (!this.alive) {
          return;
        }

        this.cachePreviousTransform();
        this.updateTimers(dt);
        this.ageTrail(dt);

        const toPlayer = Vec2.sub({ x: player.x, y: player.y }, { x: this.x, y: this.y });
        const playerDistance = Vec2.length(toPlayer);
        const toPlayerDir = playerDistance > EPSILON ? Vec2.mul(toPlayer, 1 / playerDistance) : { x: 0, y: 0 };

        this.updateState(dt, playerDistance, toPlayerDir);
        this.applyKnockbackDamping(dt);
        this.integratePosition(dt);
        this.clampToPlayfield();
      }

      cachePreviousTransform() {
        this.prevX = this.x;
        this.prevY = this.y;
        this.prevRollAngle = this.rollAngle;
      }

      updateTimers(dt) {
        this.waddleTime += dt;
        this.hitCooldown = Math.max(0, this.hitCooldown - dt);
        this.hitFlashTimer = Math.max(0, this.hitFlashTimer - dt);
        this.stunTimer = Math.max(0, this.stunTimer - dt);
        this.postAttackCooldownTimer = Math.max(0, this.postAttackCooldownTimer - dt);
      }

      updateState(dt, playerDistance, toPlayerDir) {
        if (this.stunTimer > 0) {
          this.vx = 0;
          this.vy = 0;
          this.rollAngle = 0;
          return;
        }

        if (this.state === "stalk") {
          this.updateStalkState(playerDistance, toPlayerDir);
        } else if (this.state === "windup") {
          this.updateWindupState(dt);
        } else if (this.state === "charge") {
          this.updateChargeState(dt);
        } else if (this.state === "recover") {
          this.updateRecoverState(dt);
        }
      }

      updateStalkState(playerDistance, toPlayerDir) {
        this.vx = toPlayerDir.x * this.stalkSpeed;
        this.vy = toPlayerDir.y * this.stalkSpeed;
        this.rollAngle = 0;
        if (playerDistance <= this.chargeTriggerDistance && this.postAttackCooldownTimer <= 0) {
          this.state = "windup";
          this.windupTimer = this.windupDuration;
          this.chargeDirection = toPlayerDir;
          if (Vec2.length(this.chargeDirection) <= EPSILON) {
            this.chargeDirection = { x: ENEMY_CFG.defaultChargeDirection.x, y: ENEMY_CFG.defaultChargeDirection.y };
          }
          this.vx = 0;
          this.vy = 0;
        }
      }

      updateWindupState(dt) {
        this.vx = 0;
        this.vy = 0;
        this.rollAngle = 0;
        this.windupTimer -= dt;
        if (this.windupTimer <= 0) {
          this.state = "charge";
          this.chargeTimer = this.chargeDuration;
          this.chargeElapsed = 0;
          const spinSign = this.chargeDirection.x >= 0 ? 1 : -1;
          this.chargeSpinAmount = ENEMY_CFG.chargeSpinAmount * spinSign;
        }
      }

      updateChargeState(dt) {
        this.vx = this.chargeDirection.x * this.chargeSpeed;
        this.vy = this.chargeDirection.y * this.chargeSpeed;
        this.chargeElapsed += dt;
        const chargeT = clamp(this.chargeElapsed / this.chargeDuration, 0, 1);
        this.rollAngle = this.chargeSpinAmount * easeOutCubic(chargeT);
        this.spawnChargeTrail(dt);
        this.chargeTimer -= dt;
        if (this.chargeTimer <= 0) {
          this.state = "recover";
          this.recoverTimer = this.recoverDuration;
          this.postAttackCooldownTimer = this.postAttackCooldownDuration;
        }
      }

      spawnChargeTrail(dt) {
        this.trailSpawnTimer += dt;
        while (this.trailSpawnTimer >= ENEMY_CFG.chargeTrailInterval) {
          this.trailSpawnTimer -= ENEMY_CFG.chargeTrailInterval;
          this.trail.push({
            x: this.x,
            y: this.y,
            angle: this.rollAngle,
            age: 0,
            life: ENEMY_CFG.chargeTrailLife,
            alpha: ENEMY_CFG.chargeTrailAlpha
          });
          if (this.trail.length > ENEMY_CFG.maxTrailSamples) {
            this.trail.shift();
          }
        }
      }

      updateRecoverState(dt) {
        const damp = Math.max(0, 1 - dt * ENEMY_CFG.recoverDampingRate);
        this.vx *= damp;
        this.vy *= damp;
        this.rollAngle = 0;
        this.recoverTimer -= dt;
        if (this.recoverTimer <= 0) {
          this.state = "stalk";
        }
      }

      applyKnockbackDamping(dt) {
        const knockbackDamp = Math.max(0, 1 - dt * ENEMY_CFG.knockbackDampingRate);
        this.knockbackVX *= knockbackDamp;
        this.knockbackVY *= knockbackDamp;
      }

      integratePosition(dt) {
        this.x += (this.vx + this.knockbackVX) * dt;
        this.y += (this.vy + this.knockbackVY) * dt;
      }

      clampToPlayfield() {
        const halfW = this.width * 0.5;
        const halfH = this.height * 0.5;
        if (this.entering) {
          if (this.x >= halfW && this.x <= GAME_WIDTH - halfW) {
            this.entering = false;
          }
        }
        if (!this.entering) {
          this.x = clamp(this.x, halfW, GAME_WIDTH - halfW);
        }
        this.y = clamp(this.y, halfH, GAME_HEIGHT - halfH);
      }

      isOverlappingPlayer(player) {
        const combatReach = Math.max(player.width, player.height) * ENEMY_CFG.combatReachPlayerFactor + this.hitRadius;
        return MathUtils.distanceSq(this.x, this.y, player.x, player.y) <= combatReach * combatReach;
      }

      onPlayerContact(player, game) {
        if (!this.canReceiveChargedHit(player)) {
          return;
        }

        const awayFromHit = this.getAwayFromHitDirection(player);
        this.applyChargedHit(player, awayFromHit);
        const hitX = (this.x + player.x) * 0.5;
        const hitY = (this.y + player.y) * 0.5;
        this.spawnChargedHitEffects(game, hitX, hitY, awayFromHit);

        if (this.healthQuarters <= 0) {
          this.handleDeath(game);
        }
      }

      canReceiveChargedHit(player) {
        if (!this.alive || !player.action || !this.isOverlappingPlayer(player)) {
          return false;
        }
        if (player.action.type === "dodge") {
          return false;
        }
        if (player.action.type !== "charged" || this.hitCooldown > 0) {
          return false;
        }
        if (this.lastHitByActionId === player.action.id) {
          return false;
        }
        return true;
      }

      getAwayFromHitDirection(player) {
        let awayFromHit = Vec2.sub({ x: this.x, y: this.y }, { x: player.x, y: player.y });
        awayFromHit = Vec2.normalize(awayFromHit);
        if (Vec2.length(awayFromHit) <= EPSILON) {
          return player.action.direction || { x: ENEMY_CFG.defaultChargeDirection.x, y: ENEMY_CFG.defaultChargeDirection.y };
        }
        return awayFromHit;
      }

      applyChargedHit(player, awayFromHit) {
        this.healthQuarters = Math.max(0, this.healthQuarters - 1);
        this.lastHitByActionId = player.action.id;
        this.hitFlashTimer = ENEMY_CFG.hitFlashDuration;
        this.hitCooldown = ENEMY_CFG.hitCooldownDuration;
        this.stunTimer = this.stunDuration;
        this.state = "recover";
        this.recoverTimer = this.recoverDuration;
        this.knockbackVX += awayFromHit.x * ENEMY_CFG.knockbackImpulse;
        this.knockbackVY += awayFromHit.y * ENEMY_CFG.knockbackImpulse;
      }

      spawnChargedHitEffects(game, hitX, hitY, awayFromHit) {
        game.particles.emit(hitX, hitY, FX_CFG.hitParticleCount, {
          baseAngle: Math.atan2(awayFromHit.y, awayFromHit.x),
          spread: FX_CFG.hitParticleSpread,
          minSpeed: FX_CFG.hitParticleMinSpeed,
          maxSpeed: FX_CFG.hitParticleMaxSpeed,
          minLife: FX_CFG.hitParticleMinLife,
          maxLife: FX_CFG.hitParticleMaxLife,
          minSize: FX_CFG.hitParticleMinSize,
          maxSize: FX_CFG.hitParticleMaxSize,
          colors: FX_CFG.hitParticleColors,
          drag: FX_CFG.hitParticleDrag
        });

        game.flashRings.push({
          x: hitX, y: hitY,
          maxRadius: FX_CFG.hitRingRadius,
          age: 0,
          life: FX_CFG.hitRingLife,
          type: "shockwave"
        });

        game.triggerShake(FX_CFG.hitShake.intensity, FX_CFG.hitShake.duration);
        game.triggerHitstop(FX_CFG.hitstopDuration);
        game.triggerTimeSlow(FX_CFG.hitTimeSlow.duration, FX_CFG.hitTimeSlow.minScale);
      }

      handleDeath(game) {
        this.alive = false;

        game.triggerShake(FX_CFG.deathShake.intensity, FX_CFG.deathShake.duration);
        game.triggerHitstop(FX_CFG.deathHitstopDuration);
        game.triggerTimeSlow(FX_CFG.deathTimeSlow.duration, FX_CFG.deathTimeSlow.minScale);

        game.flashRings.push({
          x: this.x, y: this.y,
          maxRadius: FX_CFG.deathRingRadius,
          age: 0,
          life: FX_CFG.deathRingLife,
          type: "deathFlash"
        });

        game.particles.emit(this.x, this.y, FX_CFG.deathParticleCount, {
          baseAngle: 0,
          spread: TAU,
          minSpeed: FX_CFG.deathParticleMinSpeed,
          maxSpeed: FX_CFG.deathParticleMaxSpeed,
          minLife: FX_CFG.deathParticleMinLife,
          maxLife: FX_CFG.deathParticleMaxLife,
          minSize: FX_CFG.deathParticleMinSize,
          maxSize: FX_CFG.deathParticleMaxSize,
          colors: FX_CFG.deathParticleColors,
          drag: FX_CFG.deathParticleDrag
        });

        game.rainbowParticles.emit(this.x, this.y, FX_CFG.rainbowMinCount + Math.floor(Math.random() * FX_CFG.rainbowExtraCount));
      }

      checkDamageToPlayer(player, game) {
        if (!this.alive || this.state !== "charge") return;
        if (player.iframeTimer > 0 || player.health <= 0) return;
        if (player.action && player.action.type === "dodge") return;
        if (!this.isOverlappingPlayer(player)) return;
        player.takeDamage(game);
      }

      interpolate(alpha) {
        this.renderX = this.prevX + (this.x - this.prevX) * alpha;
        this.renderY = this.prevY + (this.y - this.prevY) * alpha;
        this.renderRollAngle = this.prevRollAngle + (this.rollAngle - this.prevRollAngle) * alpha;
      }

      draw(ctx, nowSeconds) {
        if (!this.alive) {
          return;
        }

        const rx = this.renderX;
        const ry = this.renderY;
        const rAngle = this.renderRollAngle;

        ctx.save();
        for (let i = 0; i < this.trail.length; i += 1) {
          const t = this.trail[i];
          const alpha = (1 - t.age / t.life) * t.alpha;
          ctx.globalAlpha = alpha;
          ctx.translate(t.x, t.y);
          ctx.rotate(t.angle);
          ctx.drawImage(ratEmojiCanvas, -ratEmojiCanvas.width / 2, -ratEmojiCanvas.height / 2);
          ctx.rotate(-t.angle);
          ctx.translate(-t.x, -t.y);
        }
        ctx.restore();

        const shadowY = ry + this.height * 0.35 - 3.5;
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.14)";
        ctx.beginPath();
        ctx.ellipse(rx, shadowY, this.width * 0.5, 2.2, 0, 0, TAU);
        ctx.fill();
        ctx.fillStyle = "rgba(0, 0, 0, 0.07)";
        ctx.beginPath();
        ctx.ellipse(rx, shadowY + 0.2, this.width * 0.7, 3.2, 0, 0, TAU);
        ctx.fill();
        ctx.restore();

        let waddle = 0;
        if (this.state === "stalk" || this.state === "recover") {
          waddle = Math.sin(this.waddleTime * 12) * 0.12;
        }

        ctx.save();
        if (this.hitFlashTimer > 0) {
          ctx.globalAlpha = 0.5 + 0.5 * Math.sin(nowSeconds * 40);
        } else if (this.state === "windup") {
          const flashOn = Math.sin(nowSeconds * 36) > 0;
          ctx.globalAlpha = flashOn ? 0.4 : 1;
        }
        ctx.translate(rx, ry);
        ctx.rotate(waddle + rAngle);
        ctx.drawImage(ratEmojiCanvas, -ratEmojiCanvas.width / 2, -ratEmojiCanvas.height / 2);
        ctx.restore();
      }
    }

    class Pool {
      constructor(factory, initialSize) {
        this.factory = factory;
        this.items = [];
        for (let i = 0; i < initialSize; i++) {
          this.items.push(this.factory());
        }
      }
      get() {
        return this.items.length > 0 ? this.items.pop() : this.factory();
      }
      release(item) {
        this.items.push(item);
      }
    }

    class ParticleSystem {
      constructor() {
        this.particles = [];
        this.pool = new Pool(() => ({
          x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, size: 0, color: "", drag: 0
        }), 200);
      }

      emit(x, y, count, config) {
        for (let i = 0; i < count; i++) {
          const angle = config.baseAngle + (Math.random() - 0.5) * config.spread;
          const speed = config.minSpeed + Math.random() * (config.maxSpeed - config.minSpeed);
          const life = config.minLife + Math.random() * (config.maxLife - config.minLife);
          const size = config.minSize + Math.random() * (config.maxSize - config.minSize);
          
          const p = this.pool.get();
          p.x = x;
          p.y = y;
          p.vx = Math.cos(angle) * speed;
          p.vy = Math.sin(angle) * speed;
          p.life = life;
          p.maxLife = life;
          p.size = size;
          p.color = config.colors[Math.floor(Math.random() * config.colors.length)];
          p.drag = config.drag || 0;
          this.particles.push(p);
        }
      }

      update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];
          if (p.drag > 0) {
            const damp = Math.max(0, 1 - dt * p.drag);
            p.vx *= damp;
            p.vy *= damp;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.life -= dt;
          if (p.life <= 0) {
            this.pool.release(p);
            MathUtils.swapAndPop(this.particles, i);
          }
        }
      }

      draw(ctx) {
        ctx.save();
        for (let i = 0; i < this.particles.length; i++) {
          const p = this.particles[i];
          const t = p.life / p.maxLife;
          const currentSize = p.size * (0.3 + 0.7 * t);
          ctx.globalAlpha = t * t;
          ctx.fillStyle = p.color;
          ctx.translate(p.x, p.y);
          const angle = Math.atan2(p.vy, p.vx);
          ctx.rotate(angle);
          ctx.fillRect(-currentSize * 0.5, -currentSize * 0.3, currentSize, currentSize * 0.6);
          ctx.rotate(-angle);
          ctx.translate(-p.x, -p.y);
        }
        ctx.restore();
      }
    }

    class RainbowDeathParticleSystem {
      constructor() {
        this.particles = [];
        this.pool = new Pool(() => ({
          x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, r: 0, g: 0, b: 0, size: 0, gravity: 0, bounciness: 0, drag: 0
        }), 200);
      }

      emit(x, y, count) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * TAU;
          const speed = Math.random() * RAINBOW_CFG.speed;
          const hue = Math.random() * 360;
          const color = hslToRgb(hue, 100, 50);
          
          const p = this.pool.get();
          p.x = x;
          p.y = y;
          p.z = 0;
          p.vx = Math.cos(angle) * speed;
          p.vy = Math.sin(angle) * speed;
          p.vz = RAINBOW_CFG.zBase + Math.random() * RAINBOW_CFG.zRand;
          p.r = color.r;
          p.g = color.g;
          p.b = color.b;
          p.size = RAINBOW_CFG.sizeBase + Math.random() * RAINBOW_CFG.sizeRand;
          p.gravity = RAINBOW_CFG.gravity;
          p.bounciness = RAINBOW_CFG.bouncinessBase + Math.random() * RAINBOW_CFG.bouncinessRand;
          p.drag = RAINBOW_CFG.drag;
          this.particles.push(p);
        }
      }

      update(dt, player, groundSplotches) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];

          p.vz -= p.gravity * dt;

          const damp = Math.max(0, 1 - p.drag * dt);
          p.vx *= damp;
          p.vy *= damp;

          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.z += p.vz * dt;

          if (p.x < 0) { p.x = -p.x; p.vx = Math.abs(p.vx) * p.bounciness; }
          else if (p.x > GAME_WIDTH) { p.x = 2 * GAME_WIDTH - p.x; p.vx = -Math.abs(p.vx) * p.bounciness; }
          if (p.y < 0) { p.y = -p.y; p.vy = Math.abs(p.vy) * p.bounciness; }
          else if (p.y > GAME_HEIGHT) { p.y = 2 * GAME_HEIGHT - p.y; p.vy = -Math.abs(p.vy) * p.bounciness; }

          if (p.z <= 0 && p.vz < 0) {
            const halfW = player.width * 0.5;
            const halfH = player.height * 0.5;
            const playerMinX = player.x - halfW;
            const playerMaxX = player.x + halfW;
            const playerMinY = player.y - halfH;
            const playerMaxY = player.y + halfH;
            const stainRadius = p.size * (1.0 + Math.random());

            const directHit = MathUtils.isPointInRect(p.x, p.y, playerMinX, playerMinY, playerMaxX, playerMaxY);
            const splashHit = MathUtils.isCircleOverlappingRect(p.x, p.y, stainRadius, playerMinX, playerMinY, playerMaxX, playerMaxY);

            if (directHit || splashHit) {
              player.stains.push({
                localX: p.x - player.x,
                localY: p.y - player.y,
                r: p.r, g: p.g, b: p.b,
                radius: stainRadius,
                alpha: 0.0875 + Math.random() * 0.0375
              });
            }

            if (!directHit) {
              groundSplotches.push({
                x: p.x, y: p.y,
                r: p.r, g: p.g, b: p.b,
                radius: p.size * (1.5 + Math.random() * 1.5),
                alpha: 0.0875 + Math.random() * 0.0375
              });
            }
            this.pool.release(p);
            MathUtils.swapAndPop(this.particles, i);
          }
        }
      }

      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = RAINBOW_CFG.globalAlpha;
        for (let i = 0; i < this.particles.length; i++) {
          const p = this.particles[i];
          const visualY = p.y - p.z * RAINBOW_CFG.visualYOffset;
          const scale = 1 + p.z * RAINBOW_CFG.scaleMult;
          const currentSize = p.size * scale;
          ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
          ctx.beginPath();
          ctx.arc(p.x, visualY, currentSize, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    class Tutorial {
      constructor(game) {
        this.game = game;
        this.phase = "intro";
        this.phaseTime = 0;
        this.dodgeSlowMoTrigger = TUTORIAL_CFG.dodgeSlowMoTrigger;
        this.tutorialTimeScale = 1;
        this.textAlpha = 0;
        this.fingerAnimTime = 0;
        this.active = true;
        this.attackDir = { x: 0, y: -1 };
        this.crawlScale = TUTORIAL_CFG.crawlScale;
        this.crawlDuration = TUTORIAL_CFG.crawlDuration;
        this.slowDropRate = TUTORIAL_CFG.slowDropRate;
        this.chainSpawnRemaining = 0;
        this.chainSpawnDelay = TUTORIAL_CFG.chainSpawnDelay;
        this.chainSpawnTimer = 0;
      }

      setPhase(newPhase) {
        this.phase = newPhase;
        this.phaseTime = 0;
        this.fingerAnimTime = 0;
        this.textAlpha = 0;
      }

      update(realDt) {
        if (!this.active) return;
        this.phaseTime += realDt;
        this.fingerAnimTime += realDt;
        const { player, enemy, input } = this.game;

        switch (this.phase) {
          case "intro":
            this.handleIntro(enemy, input);
            break;
          case "waitDodge":
            this.handleWaitDodge(realDt, player, input);
            break;
          case "dodging":
            this.handleDodging(realDt, player, input);
            break;
          case "postDodgeWait":
            this.handlePostDodgeWait(input);
            break;
          case "waitHold":
            this.handleWaitHold(realDt, player, enemy, input);
            break;
          case "waitAttack":
            this.handleWaitAttack(realDt, player, input);
            break;
          case "attacking":
            this.handleAttacking(realDt, player, enemy, input);
            break;
          case "freeFightFirstRat":
            this.handleFreeFightFirstRat(enemy);
            break;
          case "chainSpawns":
            this.handleChainSpawns(realDt);
            break;
        }
      }

      handleIntro(enemy, input) {
        this.tutorialTimeScale = 1;
        input.pendingSwipe = null;
        if (enemy.state === "charge" && enemy.chargeDuration > 1e-7 &&
          enemy.chargeElapsed / enemy.chargeDuration >= this.dodgeSlowMoTrigger) {
          this.setPhase("waitDodge");
          this.tutorialTimeScale = 1;
        }
      }

      handleWaitDodge(realDt, player, input) {
        if (this.tutorialTimeScale > this.crawlScale) {
          this.tutorialTimeScale = Math.max(this.crawlScale, this.tutorialTimeScale - realDt * this.slowDropRate);
        } else if (this.phaseTime > this.crawlDuration) {
          this.tutorialTimeScale = 0;
        }
        this.textAlpha = Math.min(1, this.phaseTime * 3);
        if (input.pendingSwipe) {
          const swipe = input.pendingSwipe;
          input.pendingSwipe = null;
          player.startMove("dodge", swipe.direction);
          this.tutorialTimeScale = 1;
          this.setPhase("dodging");
        }
      }

      handleDodging(realDt, player, input) {
        this.tutorialTimeScale = 1;
        input.pendingSwipe = null;
        this.textAlpha = Math.max(0, this.textAlpha - realDt * 5);
        if (!player.action) {
          this.setPhase("postDodgeWait");
        }
      }

      handlePostDodgeWait(input) {
        this.tutorialTimeScale = 1;
        input.pendingSwipe = null;
        if (this.phaseTime >= 0.2) {
          this.setPhase("waitHold");
          this.tutorialTimeScale = 1;
        }
      }

      handleWaitHold(realDt, player, enemy, input) {
        if (this.tutorialTimeScale > this.crawlScale) {
          this.tutorialTimeScale = Math.max(this.crawlScale, this.tutorialTimeScale - realDt * this.slowDropRate);
        } else if (this.phaseTime > this.crawlDuration) {
          this.tutorialTimeScale = 0;
        }
        this.textAlpha = Math.min(1, this.phaseTime * 3);
        input.pendingSwipe = null;
        const nowSec = performance.now() * 0.001;
        const chargeProgress = input.getChargeProgress(nowSec);
        if (chargeProgress >= 1) {
          const targetEnemy = this.game.getClosestAliveEnemy(player) || enemy;
          const dir = Vec2.sub({ x: targetEnemy.x, y: targetEnemy.y }, { x: player.x, y: player.y });
          this.attackDir = Vec2.length(dir) > 1e-5 ? Vec2.normalize(dir) : { x: 0, y: -1 };
          this.setPhase("waitAttack");
        }
      }

      handleWaitAttack(realDt, player, input) {
        this.tutorialTimeScale = 0;
        this.textAlpha = Math.min(1, this.phaseTime * 3);
        if (input.pendingSwipe) {
          const swipe = input.pendingSwipe;
          input.pendingSwipe = null;
          player.startMove("charged", swipe.direction);
          this.tutorialTimeScale = 1;
          this.setPhase("attacking");
        }
      }

      handleAttacking(realDt, player, enemy, input) {
        this.tutorialTimeScale = 1;
        input.pendingSwipe = null;
        this.textAlpha = Math.max(0, this.textAlpha - realDt * 3);
        if (!enemy.alive) {
          this.chainSpawnRemaining = TUTORIAL_CFG.chainSpawnCount;
          this.chainSpawnTimer = 0;
          this.setPhase("chainSpawns");
          return;
        }
        if (!player.action && this.phaseTime > TUTORIAL_CFG.freeFightDelay) {
          this.setPhase("freeFightFirstRat");
        }
      }

      handleFreeFightFirstRat(enemy) {
        this.tutorialTimeScale = 1;
        this.textAlpha = 0;
        if (!enemy.alive) {
          this.chainSpawnRemaining = TUTORIAL_CFG.chainSpawnCount;
          this.chainSpawnTimer = 0;
          this.setPhase("chainSpawns");
        }
      }

      handleChainSpawns(realDt) {
        this.tutorialTimeScale = 1;
        this.textAlpha = 0;
        if (this.chainSpawnRemaining > 0) {
          this.chainSpawnTimer = Math.max(0, this.chainSpawnTimer - realDt);
          if (this.chainSpawnTimer <= 0) {
            this.spawnEnemyFromRandomHorizontalSide();
            this.chainSpawnRemaining -= 1;
            this.chainSpawnTimer = this.chainSpawnDelay;
          }
        } else {
          const allDead = this.game.enemies.every(e => !e.alive);
          if (allDead) {
            this.active = false;
            this.phase = "done";
          }
        }
      }

      getTimeScale() {
        return this.active ? this.tutorialTimeScale : 1;
      }

      spawnEnemyFromRandomHorizontalSide() {
        const template = this.game.enemy;
        const enemy = new TriangleEnemy(0, 0);
        const fromLeft = Math.random() < 0.5;
        const spawnX = fromLeft ? -template.width : GAME_WIDTH + template.width;
        const spawnY = GAME_HEIGHT * (0.22 + Math.random() * 0.56);

        enemy.x = spawnX;
        enemy.y = spawnY;
        enemy.prevX = spawnX;
        enemy.prevY = spawnY;
        enemy.renderX = spawnX;
        enemy.renderY = spawnY;
        enemy.vx = 0;
        enemy.vy = 0;
        enemy.knockbackVX = 0;
        enemy.knockbackVY = 0;
        enemy.alive = true;
        enemy.entering = true;
        enemy.healthQuarters = 3;
        enemy.state = "stalk";
        enemy.windupTimer = 0;
        enemy.chargeTimer = 0;
        enemy.recoverTimer = 0;
        enemy.postAttackCooldownTimer = enemy.postAttackCooldownDuration;
        enemy.lastHitByActionId = null;
        enemy.hitCooldown = 0;
        enemy.hitFlashTimer = 0;
        enemy.stunTimer = 0;
        enemy.rollAngle = 0;
        enemy.prevRollAngle = 0;
        enemy.renderRollAngle = 0;
        enemy.chargeElapsed = 0;
        enemy.trail = [];
        enemy.trailSpawnTimer = 0;

        this.game.enemies.push(enemy);
      }

      draw(ctx) {
        if (!this.active) return;

        const centerX = GAME_WIDTH * 0.5;
        const textY = GAME_HEIGHT * 0.62;
        const indicatorY = textY + 50;

        if (this.phase === "waitDodge" && this.textAlpha > 0) {
          this.drawDimOverlay(ctx);
          ctx.save();
          ctx.globalAlpha = this.textAlpha;
          this.drawText(ctx, "Swipe to dodge!", centerX, textY, 30);
          this.drawSwipeIndicator(ctx, centerX, indicatorY, { x: -1, y: 0 });
          ctx.restore();
        } else if (this.phase === "waitHold" && this.textAlpha > 0) {
          this.drawDimOverlay(ctx);
          ctx.save();
          ctx.globalAlpha = this.textAlpha;
          this.drawText(ctx, "Hold", centerX, textY, 30);
          this.drawHoldIndicator(ctx, centerX, indicatorY);
          ctx.restore();
        } else if (this.phase === "waitAttack" && this.textAlpha > 0) {
          this.drawDimOverlay(ctx);
          ctx.save();
          ctx.globalAlpha = this.textAlpha;
          this.drawText(ctx, "Then swipe to attack!", centerX, textY, 26);
          this.drawSwipeIndicator(ctx, centerX, indicatorY, this.attackDir);
          ctx.restore();
        }
      }

      drawDimOverlay(ctx) {
        ctx.save();
        ctx.globalAlpha = this.textAlpha * 0.3;
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, GAME_HEIGHT * 0.55, GAME_WIDTH, GAME_HEIGHT * 0.28);
        ctx.restore();
      }

      drawText(ctx, text, x, y, size) {
        ctx.font = `bold ${size}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillText(text, x + 1.5, y + 1.5);
        ctx.fillStyle = "#ffffff";
        ctx.fillText(text, x, y);
      }

      drawSwipeIndicator(ctx, x, y, dir) {
        const cycleTime = 1.0;
        const t = (this.fingerAnimTime % cycleTime) / cycleTime;
        const swipeLen = 35;
        const startX = x - dir.x * swipeLen;
        const startY = y - dir.y * swipeLen;
        const endX = x + dir.x * swipeLen;
        const endY = y + dir.y * swipeLen;

        const moveT = t < 0.6 ? easeOutCubic(t / 0.6) : 1;
        const fingerX = startX + (endX - startX) * moveT;
        const fingerY = startY + (endY - startY) * moveT;

        if (t < 0.6) {
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,0.35)";
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(fingerX, fingerY);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }

        const alpha = t < 0.6 ? 1 : Math.max(0, 1 - (t - 0.6) / 0.4);
        ctx.save();
        ctx.globalAlpha *= alpha;
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(fingerX, fingerY, 14, 0, TAU);
        ctx.fill();
        ctx.fillStyle = "#999999";
        ctx.beginPath();
        ctx.arc(fingerX, fingerY, 6, 0, TAU);
        ctx.fill();
        ctx.restore();

        const arrowAlpha = 0.4 + 0.3 * Math.sin(this.fingerAnimTime * 5);
        ctx.save();
        ctx.globalAlpha *= arrowAlpha;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2.5;
        const angle = Math.atan2(dir.y, dir.x);
        const tipX = x + dir.x * 28;
        const tipY = y + dir.y * 28;
        const baseX = x - dir.x * 12;
        const baseY = y - dir.y * 12;
        ctx.beginPath();
        ctx.moveTo(baseX, baseY);
        ctx.lineTo(tipX, tipY);
        ctx.stroke();
        const headLen = 9;
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(tipX - Math.cos(angle - 0.45) * headLen, tipY - Math.sin(angle - 0.45) * headLen);
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(tipX - Math.cos(angle + 0.45) * headLen, tipY - Math.sin(angle + 0.45) * headLen);
        ctx.stroke();
        ctx.restore();
      }

      drawHoldIndicator(ctx, x, y) {
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(x, y, 14, 0, TAU);
        ctx.fill();
        ctx.fillStyle = "#999999";
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, TAU);
        ctx.fill();

        const pulseT = (this.fingerAnimTime % 0.9) / 0.9;
        for (let i = 0; i < 2; i++) {
          const ringT = (pulseT + i * 0.5) % 1;
          const ringAlpha = (1 - ringT) * 0.45;
          const ringRadius = 14 + ringT * 22;
          ctx.save();
          ctx.globalAlpha *= ringAlpha;
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x, y, ringRadius, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.view = {
          scale: 1,
          offsetX: 0,
          offsetY: 0
        };
        this.screen = {
          width: window.innerWidth,
          height: window.innerHeight
        };

        this.bgImage = new Image();
        this.bgImage.src = GRASS_SVG;
        this.bgPattern = null;
        this.bgImage.onload = () => {
          this.bgPattern = this.ctx.createPattern(this.bgImage, "repeat");
        };

        this.input = new InputSystem((event) => this.eventToWorld(event));
        this.input.bind(canvas);
        this.player = new Player();
        this.enemy = new TriangleEnemy(GAME_WIDTH * 0.5, 180);
        this.enemies = [this.enemy];
        this.enemy.state = "charge";
        this.enemy.chargeDirection = { x: 0, y: 1 };
        this.enemy.chargeTimer = this.enemy.chargeDuration;
        this.enemy.chargeElapsed = 0;
        this.enemy.chargeSpinAmount = ENEMY_CFG.chargeSpinAmount;
        this.enemy.healthQuarters = 1;

        this.lastTimestamp = 0;
        this.accumulator = 0;
        this.fixedStep = 1 / 120;
        this.maxFrame = 0.05;

        this.shakeTimer = 0;
        this.shakeDuration = 0;
        this.shakeIntensity = 0;
        this.shakeOffsetX = 0;
        this.shakeOffsetY = 0;

        this.hitstopTimer = 0;

        this.timeScale = 1;
        this.timeSlowTimer = 0;
        this.timeSlowDuration = 0;
        this.timeSlowMinScale = 0.15;

        this.particles = new ParticleSystem();
        this.rainbowParticles = new RainbowDeathParticleSystem();
        this.flashRings = [];
        this.groundSplotches = [];

        this.tutorial = new Tutorial(this);

        window.addEventListener("resize", () => this.resize());
        this.resize();
      }

      resize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
        this.canvas.width = Math.floor(this.screen.width * dpr);
        this.canvas.height = Math.floor(this.screen.height * dpr);
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const scale = Math.min(this.screen.width / GAME_WIDTH, this.screen.height / GAME_HEIGHT);
        this.view.scale = scale;
        this.view.offsetX = (this.screen.width - GAME_WIDTH * scale) * 0.5;
        this.view.offsetY = (this.screen.height - GAME_HEIGHT * scale) * 0.5;
      }

      eventToWorld(event) {
        const rect = this.canvas.getBoundingClientRect();
        const sx = event.clientX - rect.left;
        const sy = event.clientY - rect.top;
        return {
          x: (sx - this.view.offsetX) / this.view.scale,
          y: (sy - this.view.offsetY) / this.view.scale
        };
      }

      triggerShake(intensity, duration) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
        this.shakeTimer = duration;
      }

      triggerHitstop(duration) {
        this.hitstopTimer = Math.max(this.hitstopTimer, duration);
      }

      triggerTimeSlow(duration, minScale) {
        this.timeSlowDuration = duration;
        this.timeSlowTimer = duration;
        this.timeSlowMinScale = minScale;
      }

      getClosestAliveEnemy(fromEntity) {
        let bestEnemy = null;
        let bestDistSq = Infinity;
        for (let i = 0; i < this.enemies.length; i++) {
          const enemy = this.enemies[i];
          if (!enemy.alive) {
            continue;
          }
          const distSq = MathUtils.distanceSq(enemy.x, enemy.y, fromEntity.x, fromEntity.y);
          if (distSq < bestDistSq) {
            bestDistSq = distSq;
            bestEnemy = enemy;
          }
        }
        return bestEnemy;
      }

      update(dt) {
        this.particles.update(dt);
        this.rainbowParticles.update(dt, this.player, this.groundSplotches);

        for (let i = this.flashRings.length - 1; i >= 0; i--) {
          this.flashRings[i].age += dt;
          if (this.flashRings[i].age >= this.flashRings[i].life) {
            MathUtils.swapAndPop(this.flashRings, i);
          }
        }

        if (this.shakeTimer > 0) {
          this.shakeTimer = Math.max(0, this.shakeTimer - dt);
          const t = this.shakeTimer / this.shakeDuration;
          const mag = this.shakeIntensity * t;
          this.shakeOffsetX = (Math.random() * 2 - 1) * mag;
          this.shakeOffsetY = (Math.random() * 2 - 1) * mag;
        } else {
          this.shakeOffsetX = 0;
          this.shakeOffsetY = 0;
        }

        if (this.hitstopTimer > 0) {
          this.hitstopTimer = Math.max(0, this.hitstopTimer - dt);
          return;
        }

        const nowSeconds = performance.now() * 0.001;
        this.player.update(dt, this.input, nowSeconds);
        for (let i = 0; i < this.enemies.length; i++) {
          this.enemies[i].update(dt, this.player);
        }
        for (let i = 0; i < this.enemies.length; i++) {
          this.enemies[i].onPlayerContact(this.player, this);
          this.enemies[i].checkDamageToPlayer(this.player, this);
        }
      }

      render() {
        const ctx = this.ctx;
        const w = this.screen.width;
        const h = this.screen.height;

        this.renderBackdrop(ctx, w, h);

        ctx.save();
        ctx.translate(this.view.offsetX, this.view.offsetY);
        ctx.scale(this.view.scale, this.view.scale);
        ctx.translate(this.shakeOffsetX, this.shakeOffsetY);

        this.renderPlayfield(ctx);
        this.renderGroundSplotches(ctx);
        const nowSeconds = performance.now() * 0.001;
        this.renderEntities(ctx, nowSeconds);
        this.renderParticles(ctx);
        this.renderFlashRings(ctx);
        this.renderTutorial(ctx);
        this.renderHealthBar(ctx);
        ctx.restore();
      }

      renderBackdrop(ctx, w, h) {
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = "#4a4a4a";
        ctx.fillRect(0, 0, w, h);
      }

      renderPlayfield(ctx) {
        if (this.bgPattern) {
          ctx.fillStyle = this.bgPattern;
        } else {
          ctx.fillStyle = "#7cb342"; // Fallback color
        }
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        ctx.strokeStyle = "#558b2f"; // Darker green border
        ctx.lineWidth = 4;
        ctx.strokeRect(2, 2, GAME_WIDTH - 4, GAME_HEIGHT - 4);
      }

      renderGroundSplotches(ctx) {
        for (let i = 0; i < this.groundSplotches.length; i++) {
          const s = this.groundSplotches[i];
          ctx.save();
          ctx.globalAlpha = s.alpha;
          ctx.fillStyle = `rgb(${s.r},${s.g},${s.b})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.radius, 0, TAU);
          ctx.fill();
          ctx.restore();
        }
      }

      renderEntities(ctx, nowSeconds) {
        for (let i = 0; i < this.enemies.length; i++) {
          this.enemies[i].draw(ctx, nowSeconds);
        }
        this.player.draw(ctx);
      }

      renderParticles(ctx) {
        this.particles.draw(ctx);
        this.rainbowParticles.draw(ctx);
      }

      renderFlashRings(ctx) {
        for (let i = 0; i < this.flashRings.length; i++) {
          const ring = this.flashRings[i];
          const t = ring.age / ring.life;
          const radius = ring.maxRadius * easeOutCubic(t);
          const alpha = 1 - t;

          ctx.save();
          ctx.globalAlpha = alpha;

          if (ring.type === "shockwave") {
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = Math.max(0.5, 4 * (1 - t));
            ctx.beginPath();
            ctx.arc(ring.x, ring.y, radius, 0, TAU);
            ctx.stroke();
          } else if (ring.type === "deathFlash") {
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(ring.x, ring.y, radius, 0, TAU);
            ctx.fill();
          }

          ctx.restore();
        }
      }

      renderTutorial(ctx) {
        if (this.tutorial) {
          this.tutorial.draw(ctx);
        }
      }

      renderHealthBar(ctx) {
        const hbWidth = UI_CFG.healthBarWidth;
        const hbHeight = UI_CFG.healthBarHeight;
        const hbX = (GAME_WIDTH - hbWidth) * 0.5;
        const hbY = GAME_HEIGHT - UI_CFG.healthBarBottomMargin;
        const hpFrac = this.player.health / this.player.maxHealth;
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = "#000000";
        ctx.fillRect(hbX - 1, hbY - 1, hbWidth + 2, hbHeight + 2);
        ctx.restore();
        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = "#440000";
        ctx.fillRect(hbX, hbY, hbWidth, hbHeight);
        ctx.restore();
        if (hpFrac > 0) {
          ctx.fillStyle = "#cc2222";
          ctx.fillRect(hbX, hbY, hbWidth * hpFrac, hbHeight);
        }
      }

      frame = (timestamp) => {
        if (!this.lastTimestamp) {
          this.lastTimestamp = timestamp;
        }

        let frameDt = (timestamp - this.lastTimestamp) / 1000;
        this.lastTimestamp = timestamp;
        frameDt = clamp(frameDt, 0, this.maxFrame);

        if (this.tutorial && this.tutorial.active) {
          this.tutorial.update(frameDt);
        }

        if (this.timeSlowTimer > 0) {
          this.timeSlowTimer = Math.max(0, this.timeSlowTimer - frameDt);
          const elapsed = 1 - (this.timeSlowTimer / this.timeSlowDuration);
          this.timeScale = this.timeSlowMinScale + (1 - this.timeSlowMinScale) * (elapsed * elapsed * elapsed);
        } else {
          this.timeScale = 1;
        }

    const holdDt = this.hitstopTimer > 0 ? 0 : frameDt * this.timeScale;
    this.input.advanceHold(holdDt);

    this.accumulator += frameDt;
    while (this.accumulator >= this.fixedStep) {
      const tutScale = this.tutorial ? this.tutorial.getTimeScale() : 1;
      this.update(this.fixedStep * this.timeScale * tutScale);
      this.accumulator -= this.fixedStep;
    }

        const interpAlpha = this.fixedStep > 1e-7 ? clamp(this.accumulator / this.fixedStep, 0, 1) : 1;
        for (let i = 0; i < this.enemies.length; i++) {
          this.enemies[i].interpolate(interpAlpha);
        }

        this.render();
        requestAnimationFrame(this.frame);
      };

      start() {
        requestAnimationFrame(this.frame);
      }
    }

    const game = new Game(document.getElementById("gameCanvas"));
    game.start();
  </script>
</body>
</html>
