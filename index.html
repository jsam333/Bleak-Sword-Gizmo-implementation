<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bleak Sword Gizmo Prototype</title>
  <style>
    :root {
      color-scheme: light;
    }

    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #6a6a6a;
      font-family: Arial, sans-serif;
    }

    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #6a6a6a;
    }
    #devPanel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      font-family: Arial, sans-serif;
    }

    #devPanel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 16px;
    }

    #devPanel select {
      padding: 4px;
      font-size: 14px;
      background: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      margin-top: 5px;
      display: block;
      width: 100%;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="devPanel">
    <h3>Dev Settings</h3>
    <label for="levelSelect">Jump to Level:</label>
    <select id="levelSelect">
      <option value="1">Level 1 (Dirt)</option>
      <option value="2">Level 2 (Sand)</option>
      <option value="3">Level 3 (Stone)</option>
      <option value="4">Level 4 (Swamp)</option>
    </select>
  </div>
  <canvas id="gameCanvas"></canvas>
  <script>
    "use strict";

    const GAME_WIDTH = 500;
    const GAME_HEIGHT = 720;
    const TAU = Math.PI * 2;
    const EPSILON = 1e-7;

        const LEVEL_BACKGROUNDS = {
      GRASS: `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
      <rect width="100" height="100" fill="%237cb342"/>
      <path d="M10,20 Q15,5 20,20 Q25,5 30,20" stroke="%23689f38" stroke-width="2" fill="none"/>
      <path d="M40,50 Q45,35 50,50 Q55,35 60,50" stroke="%23558b2f" stroke-width="2" fill="none"/>
      <path d="M70,80 Q75,65 80,80 Q85,65 90,80" stroke="%23689f38" stroke-width="2" fill="none"/>
      <path d="M20,70 Q25,55 30,70 Q35,55 40,70" stroke="%238bc34a" stroke-width="2" fill="none"/>
      <path d="M80,30 Q85,15 90,30 Q95,15 100,30" stroke="%23558b2f" stroke-width="2" fill="none"/>
    </svg>`,
      DIRT: `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
      <rect width="100" height="100" fill="%238d6e63"/>
      <path d="M15,25 Q30,15 45,25 T75,25" stroke="%23795548" stroke-width="3" fill="none"/>
      <path d="M25,65 Q40,55 55,65 T85,65" stroke="%236d4c41" stroke-width="2" fill="none"/>
      <circle cx="20" cy="80" r="3" fill="%235d4037"/>
      <circle cx="80" cy="30" r="4" fill="%23795548"/>
      <circle cx="50" cy="90" r="2" fill="%235d4037"/>
    </svg>`,
      SAND: `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
      <rect width="100" height="100" fill="%23ffe082"/>
      <path d="M0,30 Q25,10 50,30 T100,30" stroke="%23ffd54f" stroke-width="4" fill="none"/>
      <path d="M0,70 Q25,50 50,70 T100,70" stroke="%23ffca28" stroke-width="3" fill="none"/>
      <circle cx="15" cy="45" r="1.5" fill="%23ffc107"/>
      <circle cx="75" cy="85" r="2" fill="%23ffca28"/>
    </svg>`,
      STONE: `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
      <rect width="100" height="100" fill="%23757575"/>
      <rect x="0" y="0" width="48" height="30" fill="%239e9e9e" stroke="%23616161" stroke-width="2"/>
      <rect x="50" y="0" width="50" height="30" fill="%23bdbdbd" stroke="%23616161" stroke-width="2"/>
      <rect x="0" y="32" width="25" height="35" fill="%23bdbdbd" stroke="%23616161" stroke-width="2"/>
      <rect x="27" y="32" width="50" height="35" fill="%239e9e9e" stroke="%23616161" stroke-width="2"/>
      <rect x="79" y="32" width="21" height="35" fill="%23e0e0e0" stroke="%23616161" stroke-width="2"/>
      <rect x="0" y="69" width="40" height="31" fill="%239e9e9e" stroke="%23616161" stroke-width="2"/>
      <rect x="42" y="69" width="58" height="31" fill="%23bdbdbd" stroke="%23616161" stroke-width="2"/>
    </svg>`,
      SWAMP: `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
      <rect width="100" height="100" fill="%231b3320"/>
      <path d="M10,20 Q20,30 40,20 Q50,10 60,25 T90,20" stroke="%232e4d2a" stroke-width="6" fill="none"/>
      <path d="M5,60 Q30,50 50,65 T95,60" stroke="%23223820" stroke-width="8" fill="none"/>
      <ellipse cx="70" cy="75" rx="15" ry="8" fill="%23243118"/>
      <ellipse cx="25" cy="35" rx="10" ry="5" fill="%23243118"/>
      <circle cx="75" cy="72" r="2" fill="%23435e30"/>
      <circle cx="65" cy="78" r="1.5" fill="%23435e30"/>
      <circle cx="22" cy="36" r="1.5" fill="%23435e30"/>
      <circle cx="30" cy="33" r="1" fill="%23435e30"/>
      <path d="M85,100 Q80,85 85,75" stroke="%23385723" stroke-width="2" fill="none"/>
      <line x1="85" y1="80" x2="85" y2="72" stroke="%234e342e" stroke-width="3" stroke-linecap="round"/>
      <path d="M15,100 Q20,80 15,65" stroke="%23385723" stroke-width="2" fill="none"/>
      <line x1="15" y1="72" x2="15" y2="62" stroke="%234e342e" stroke-width="3" stroke-linecap="round"/>
    </svg>`
    };

    const ENEMY_STATES = {
      STALK: "stalk",
      WINDUP: "windup",
      CHARGE: "charge",
      RECOVER: "recover"
    };

    const TUTORIAL_PHASES = {
      INTRO: "intro",
      WAIT_DODGE: "waitDodge",
      DODGING: "dodging",
      POST_DODGE_WAIT: "postDodgeWait",
      WAIT_HOLD: "waitHold",
      WAIT_ATTACK: "waitAttack",
      ATTACKING: "attacking",
      FREE_FIGHT_FIRST_RAT: "freeFightFirstRat",
      CHAIN_SPAWNS: "chainSpawns",
      COMPLETE_DELAY: "completeDelay",
      WAITING_FOR_INPUT: "waitingForInput",
      DONE: "done"
    };


    const INPUT_CFG = {
      minSwipeDistance: 14,
      chargeStartDelay: 0.1,
      chargeFillDuration: 0.2,
      chargeGraceThreshold: 0.75
    };

    const PLAYER_CFG = {
      width: 10.08,
      height: 43.2,
      maxHealth: 4,
      iframeDuration: 0.5,
      hitFlashDuration: 0.3,
      dodgeDuration: 0.12,
      chargedDuration: 0.2,
      dodgeTravel: 78,
      chargedTravel: 150,
      dodgeSpin: Math.PI * 0.8,
      chargedSpin: TAU * 2,
      chargedTrailInterval: 0.0064,
      dodgeTrailInterval: 0.016,
      dodgeTrailLife: 0.32,
      chargedTrailLife: 0.44,
      dodgeTrailAlpha: 0.2,
      chargedTrailAlpha: 0.3,
      maxTrailSamples: 48,
      idleDampingRate: 18,
      shakeOnHit: { intensity: 8, duration: 0.2 },
      trailPositionThresholdSq: 0.01,
      trailAngleThreshold: 0.01
    };

    const ENEMY_CFG = {
      width: 33,
      height: 30,
      hitRadius: 18,
      maxHealth: 4,
      chargeTriggerDistance: 75,
      windupDuration: 0.57,
      chargeDuration: 0.256,
      recoverDuration: 0.3,
      postAttackCooldownDuration: 0.75,
      stalkSpeed: 36,
      chargeSpeed: 560,
      stunDuration: 0.32,
      chargeSpinAmount: TAU * 1.4,
      chargeTrailInterval: 0.016,
      chargeTrailLife: 0.34,
      chargeTrailAlpha: 0.24,
      maxTrailSamples: 36,
      recoverDampingRate: 10,
      knockbackDampingRate: 7,
      combatReachPlayerFactor: 0.38,
      hitFlashDuration: 0.09,
      hitCooldownDuration: 0.16,
      knockbackImpulse: 520,
      defaultChargeDirection: { x: 0, y: 1 },
      separationRadiusSq: 1600,
      separationForce: 40
    };

    const PROJECTILE_CFG = {
      speed: 350,
      radius: 6,
      trailInterval: 0.016,
      trailLife: 0.25,
      trailAlpha: 0.4,
      maxTrailSamples: 20
    };

    const WEB_CFG = {
      projectileSpeed: 150,
      trapRadius: 52,
      trapLifetime: 5,
      trapFadeTime: 0.2
    };

    const FX_CFG = {
      hitParticleCount: 12,
      hitParticleSpread: Math.PI * 0.8,
      hitParticleMinSpeed: 180,
      hitParticleMaxSpeed: 420,
      hitParticleMinLife: 0.15,
      hitParticleMaxLife: 0.35,
      hitParticleMinSize: 3,
      hitParticleMaxSize: 7,
      hitParticleColors: ["#ffffff", "#ffffaa", "#ffdd66"],
      hitParticleDrag: 5,
      hitRingRadius: 80,
      hitRingLife: 0.25,
      hitShake: { intensity: 6, duration: 0.15 },
      hitstopDuration: 0.03,
      hitTimeSlow: { duration: 0.3, minScale: 0.15 },
      deathShake: { intensity: 14, duration: 0.3 },
      deathHitstopDuration: 0.06,
      deathTimeSlow: { duration: 0.3, minScale: 0.15 },
      deathRingRadius: 120,
      deathRingLife: 0.4,
      deathParticleCount: 24,
      deathParticleMinSpeed: 100,
      deathParticleMaxSpeed: 350,
      deathParticleMinLife: 0.3,
      deathParticleMaxLife: 0.6,
      deathParticleMinSize: 4,
      deathParticleMaxSize: 10,
      deathParticleColors: ["#d62222", "#ff4444", "#ff8800", "#ffaa22"],
      deathParticleDrag: 3,
      rainbowMinCount: 75,
      rainbowExtraCount: 25
    };

    const UI_CFG = {
      healthBarWidth: 160,
      healthBarHeight: 10,
      healthBarBottomMargin: 24
    };

    const RAINBOW_CFG = {
      speed: 520,
      zBase: 250,
      zRand: 250,
      sizeBase: 3,
      sizeRand: 5,
      gravity: 600,
      bouncinessBase: 0.5,
      bouncinessRand: 0.2,
      drag: 1.5,
      visualYOffset: 0.7,
      scaleMult: 0.002,
      globalAlpha: 0.425
    };

    const TUTORIAL_CFG = {
      dodgeSlowMoTrigger: 0.45,
      crawlScale: 0.03,
      crawlDuration: 2.8,
      slowDropRate: 12,
      chainSpawnDelay: 0.2,
      chainSpawnCount: 2,
      waitHoldDelay: 0.2,
      freeFightDelay: 0.5
    };

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function easeOutCubic(t) {
      const invT = 1 - t;
      return 1 - (invT * invT * invT);
    }

    function createEmojiCanvas(emoji, size) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const fontSize = size * 1.2;
      canvas.width = fontSize * 1.5;
      canvas.height = fontSize * 1.5;
      ctx.font = `${fontSize}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(emoji, canvas.width / 2, canvas.height / 2);
      return canvas;
    }

    const EMOJI_CANVASES = {
      rat: createEmojiCanvas("ðŸ€", ENEMY_CFG.height),
      bat: createEmojiCanvas("ðŸ¦‡", ENEMY_CFG.height),
      snake: createEmojiCanvas("ðŸ", ENEMY_CFG.height * 2),
      spider: createEmojiCanvas("ðŸ•·ï¸", ENEMY_CFG.height),
      boar: createEmojiCanvas("ðŸ—", ENEMY_CFG.height * 1.5),
      player: createEmojiCanvas("âš”ï¸", PLAYER_CFG.height * 0.5),
      drop: createEmojiCanvas("ðŸ’§", PROJECTILE_CFG.radius * 3),
      web: createEmojiCanvas("ðŸ•¸ï¸", WEB_CFG.trapRadius)
    };

    class MathUtils {
      static swapAndPop(array, index) {
        const last = array.length - 1;
        if (index !== last) {
          array[index] = array[last];
        }
        array.pop();
      }

      static distanceSq(x1, y1, x2, y2) {
        const dx = x1 - x2;
        const dy = y1 - y2;
        return dx * dx + dy * dy;
      }

      static isPointInRect(x, y, minX, minY, maxX, maxY) {
        return x >= minX && x <= maxX && y >= minY && y <= maxY;
      }

      static isCircleOverlappingRect(circleX, circleY, radius, rectMinX, rectMinY, rectMaxX, rectMaxY) {
        if (MathUtils.isPointInRect(circleX, circleY, rectMinX, rectMinY, rectMaxX, rectMaxY)) {
          return true;
        }
        const closestX = clamp(circleX, rectMinX, rectMaxX);
        const closestY = clamp(circleY, rectMinY, rectMaxY);
        return MathUtils.distanceSq(circleX, circleY, closestX, closestY) <= radius * radius;
      }
    }

    class Vec2 {
      static add(a, b) {
        return { x: a.x + b.x, y: a.y + b.y };
      }

      static sub(a, b) {
        return { x: a.x - b.x, y: a.y - b.y };
      }

      static mul(a, scalar) {
        return { x: a.x * scalar, y: a.y * scalar };
      }

      static length(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      }

      static normalize(v) {
        const len = Vec2.length(v);
        if (len <= EPSILON) {
          return { x: 0, y: 0 };
        }
        return { x: v.x / len, y: v.y / len };
      }
    }

    function hslToRgb(h, s, l) {
      s /= 100;
      l /= 100;
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = l - c / 2;
      let r, g, b;
      if (h < 60) { r = c; g = x; b = 0; }
      else if (h < 120) { r = x; g = c; b = 0; }
      else if (h < 180) { r = 0; g = c; b = x; }
      else if (h < 240) { r = 0; g = x; b = c; }
      else if (h < 300) { r = x; g = 0; b = c; }
      else { r = c; g = 0; b = x; }
      return {
        r: Math.round((r + m) * 255),
        g: Math.round((g + m) * 255),
        b: Math.round((b + m) * 255)
      };
    }

    class InputSystem {
      constructor(getWorldPointer) {
        this.getWorldPointer = getWorldPointer;
        this.activePointerId = null;
        this.down = false;
        this.start = { x: 0, y: 0 };
        this.current = { x: 0, y: 0 };
        this.holdGameDuration = 0;
        this.pendingSwipe = null;

        this.minSwipeDistance = INPUT_CFG.minSwipeDistance;
        this.chargeStartDelay = INPUT_CFG.chargeStartDelay;
        this.chargeFillDuration = INPUT_CFG.chargeFillDuration;
        this.fullChargeThreshold = this.chargeStartDelay + this.chargeFillDuration;
        this.chargeGraceThreshold = INPUT_CFG.chargeGraceThreshold;
      }

      bind(canvas) {
        canvas.addEventListener("pointerdown", (event) => this.onPointerDown(event));
        canvas.addEventListener("pointermove", (event) => this.onPointerMove(event));
        canvas.addEventListener("pointerup", (event) => this.onPointerUp(event));
        canvas.addEventListener("pointercancel", (event) => this.onPointerUp(event));
      }

      isInPlayfield(point) {
        return point.x >= 0 && point.x <= GAME_WIDTH && point.y >= 0 && point.y <= GAME_HEIGHT;
      }

      onPointerDown(event) {
        if (this.down) {
          return;
        }

        const world = this.getWorldPointer(event);
        if (!world || !this.isInPlayfield(world)) {
          return;
        }

        this.down = true;
        this.activePointerId = event.pointerId;
        this.start = world;
        this.current = world;
        this.holdGameDuration = 0;
        this.pendingSwipe = null;
      }

      onPointerMove(event) {
        if (!this.down || event.pointerId !== this.activePointerId) {
          return;
        }
        const world = this.getWorldPointer(event);
        if (!world) {
          return;
        }
        this.current = world;
      }

      onPointerUp(event) {
        if (!this.down || event.pointerId !== this.activePointerId) {
          return;
        }

        const world = this.getWorldPointer(event);
        const releasePos = world || this.current;
        const holdDuration = this.holdGameDuration;
        const swipeVec = Vec2.sub(releasePos, this.start);
        const swipeDistance = Vec2.length(swipeVec);

        if (swipeDistance >= this.minSwipeDistance) {
          const chargeAtRelease = holdDuration < this.chargeStartDelay ? 0
            : clamp((holdDuration - this.chargeStartDelay) / this.chargeFillDuration, 0, 1);
          this.pendingSwipe = {
            direction: Vec2.normalize(swipeVec),
            distance: swipeDistance,
            holdDuration,
            fullyCharged: chargeAtRelease >= this.chargeGraceThreshold
          };
        }

        this.down = false;
        this.activePointerId = null;
      }

      advanceHold(dt) {
        if (!this.down) {
          return;
        }
        this.holdGameDuration += dt;
      }

      consumeSwipe() {
        const swipe = this.pendingSwipe;
        this.pendingSwipe = null;
        return swipe;
      }

      getHoldDuration(nowSeconds) {
        if (!this.down) {
          return 0;
        }
        return this.holdGameDuration;
      }

      getChargeProgress(nowSeconds) {
        const hold = this.getHoldDuration(nowSeconds);
        if (hold < this.chargeStartDelay) {
          return 0;
        }
        return clamp((hold - this.chargeStartDelay) / this.chargeFillDuration, 0, 1);
      }
    }

    class Entity {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.width = width;
        this.height = height;
        this.trail = [];
        this.trailSpawnTimer = 0;
      }

      clampToPlayfield() {
        const halfW = this.width * 0.5;
        const halfH = this.height * 0.5;
        this.x = clamp(this.x, halfW, GAME_WIDTH - halfW);
        this.y = clamp(this.y, halfH, GAME_HEIGHT - halfH);
      }

      spawnTrailSamples(dt, interval, life, alpha, maxSamples, transform) {
        this.trailSpawnTimer += dt;
        while (this.trailSpawnTimer >= interval) {
          this.trailSpawnTimer -= interval;
          this.trail.push({
            x: transform.x,
            y: transform.y,
            angle: transform.angle || 0,
            age: 0,
            life: life,
            alpha: alpha
          });
          if (this.trail.length > maxSamples) {
            this.trail.shift();
          }
        }
      }

      ageTrail(dt) {
        for (let i = this.trail.length - 1; i >= 0; i -= 1) {
          const sample = this.trail[i];
          sample.age += dt;
          if (sample.age >= sample.life) {
            MathUtils.swapAndPop(this.trail, i);
          }
        }
      }
    }

    class Player extends Entity {
      constructor() {
        super(GAME_WIDTH * 0.5, GAME_HEIGHT * 0.5, PLAYER_CFG.width, PLAYER_CFG.height);
        this.baseAngle = 0;
        this.spinAngle = 0;

        this.action = null;
        this.actionSerial = 0;

        this.chargeProgress = 0;
        this.chargeVisible = false;

        this.maxHealth = PLAYER_CFG.maxHealth;
        this.health = this.maxHealth;
        this.displayHealth = this.maxHealth;
        this.iframeDuration = PLAYER_CFG.iframeDuration;
        this.iframeTimer = 0;
        this.hitFlashTimer = 0;
        this.onWeb = false;
      }

      startMove(type, direction) {
        const dir = Vec2.normalize(direction);
        const horizontalSign = dir.x >= 0 ? 1 : -1;

        const isDodge = type === "dodge";
        const duration = isDodge ? PLAYER_CFG.dodgeDuration : PLAYER_CFG.chargedDuration;
        const travel = isDodge ? PLAYER_CFG.dodgeTravel : PLAYER_CFG.chargedTravel;
        const spins = isDodge ? PLAYER_CFG.dodgeSpin * horizontalSign : PLAYER_CFG.chargedSpin * horizontalSign;
        this.actionSerial += 1;

        this.action = {
          id: this.actionSerial,
          type,
          direction: dir,
          duration,
          elapsed: 0,
          travel,
          spins,
          startAngle: 0,
          prevTravelT: 0
        };
      }

      takeDamage(game) {
        if (this.iframeTimer > 0 || this.health <= 0) return;
        this.health = Math.max(0, this.health - 1);
        this.iframeTimer = this.iframeDuration;
        this.hitFlashTimer = PLAYER_CFG.hitFlashDuration;
        game.triggerShake(PLAYER_CFG.shakeOnHit.intensity, PLAYER_CFG.shakeOnHit.duration);
      }

      update(dt, input, nowSeconds, game) {
        this.updateStatusTimers(dt);
        this.updateWebState(game);
        const holdDuration = input.getHoldDuration(nowSeconds);
        this.chargeVisible = input.down && holdDuration >= input.chargeStartDelay;
        this.chargeProgress = input.getChargeProgress(nowSeconds);
        this.consumeQueuedSwipe(input);
        this.updateAction(dt, game);
        this.applyPostActionDamping(dt);
        this.applyMovement(dt);
        this.clampToPlayfield();
        this.ageTrail(dt);
      }

      updateStatusTimers(dt) {
        this.iframeTimer = Math.max(0, this.iframeTimer - dt);
        this.hitFlashTimer = Math.max(0, this.hitFlashTimer - dt);
        if (this.displayHealth > this.health) {
          this.displayHealth = Math.max(this.health, this.displayHealth - dt * 2.5);
        }
      }

      updateWebState(game) {
        this.onWeb = false;
        if (!game || !game.webs || game.webs.length === 0) {
          return;
        }
        for (let i = 0; i < game.webs.length; i++) {
          if (game.webs[i].contains(this.x, this.y)) {
            this.onWeb = true;
            return;
          }
        }
      }

      getWebMoveMultiplier(game, x = this.x, y = this.y) {
        if (!game || !game.webs || game.webs.length === 0) {
          return 1;
        }
        for (let i = 0; i < game.webs.length; i += 1) {
          if (game.webs[i].contains(x, y)) {
            return 0.5;
          }
        }
        return 1;
      }

      getWebAdjustedTravel(game, startX, startY, direction, baseDistance) {
        if (baseDistance <= 0) {
          return { distance: 0, endX: startX, endY: startY };
        }
        const stepCount = Math.max(1, Math.ceil(baseDistance / 4));
        const baseStepDistance = baseDistance / stepCount;
        let x = startX;
        let y = startY;
        let distance = 0;

        for (let i = 0; i < stepCount; i += 1) {
          const webMoveMultiplier = this.getWebMoveMultiplier(game, x, y);
          const stepDistance = baseStepDistance * webMoveMultiplier;
          x += direction.x * stepDistance;
          y += direction.y * stepDistance;
          distance += stepDistance;
        }

        return { distance, endX: x, endY: y };
      }

      resetPosition() {
        this.x = GAME_WIDTH * 0.5;
        this.y = GAME_HEIGHT * 0.5;
        this.vx = 0;
        this.vy = 0;
        this.action = null;
        this.trail = [];
        this.spinAngle = 0;
        this.health = this.maxHealth;
        this.displayHealth = this.maxHealth;
        this.onWeb = false;
      }

      consumeQueuedSwipe(input) {
        const swipe = input.consumeSwipe();
        if (swipe) {
          const type = swipe.fullyCharged ? "charged" : "dodge";
          this.startMove(type, swipe.direction);
        }
      }

      updateAction(dt, game) {
        if (this.action) {
          const frameStartX = this.x;
          const frameStartY = this.y;
          const frameStartAngle = this.spinAngle;
          let webCheckX = this.x;
          let webCheckY = this.y;
          this.action.elapsed += dt;
          const t = clamp(this.action.elapsed / this.action.duration, 0, 1);
          if (this.action.type === "charged") {
            const travelT = easeOutCubic(t);
            const baseDeltaTravel = (travelT - this.action.prevTravelT) * this.action.travel;
            this.action.prevTravelT = travelT;
            const webAdjustedTravel = this.getWebAdjustedTravel(
              game,
              this.x,
              this.y,
              this.action.direction,
              baseDeltaTravel
            );
            const deltaTravel = webAdjustedTravel.distance;
            const moveX = this.action.direction.x * deltaTravel;
            const moveY = this.action.direction.y * deltaTravel;
            this.x = webAdjustedTravel.endX;
            this.y = webAdjustedTravel.endY;
            webCheckX = this.x;
            webCheckY = this.y;
            if (dt > EPSILON) {
              this.vx = moveX / dt;
              this.vy = moveY / dt;
            } else {
              this.vx = 0;
              this.vy = 0;
            }
          } else {
            const baseDistance = (this.action.travel / this.action.duration) * dt;
            const webAdjustedTravel = this.getWebAdjustedTravel(
              game,
              this.x,
              this.y,
              this.action.direction,
              baseDistance
            );
            if (dt > EPSILON) {
              this.vx = this.action.direction.x * (webAdjustedTravel.distance / dt);
              this.vy = this.action.direction.y * (webAdjustedTravel.distance / dt);
            } else {
              this.vx = 0;
              this.vy = 0;
            }
            webCheckX = webAdjustedTravel.endX;
            webCheckY = webAdjustedTravel.endY;
          }
          this.onWeb = this.getWebMoveMultiplier(game, webCheckX, webCheckY) < 1;
          this.spinAngle = this.action.startAngle + this.action.spins * easeOutCubic(t);

          const trailInterval = this.action.type === "charged"
            ? PLAYER_CFG.chargedTrailInterval
            : PLAYER_CFG.dodgeTrailInterval;
          this.trailSpawnTimer += dt;
          while (this.trailSpawnTimer >= trailInterval) {
            const sampleTimeInFrame = dt - (this.trailSpawnTimer - trailInterval);
            const sampleT = dt > EPSILON ? clamp(sampleTimeInFrame / dt, 0, 1) : 1;
            const sampleX = frameStartX + (this.x - frameStartX) * sampleT;
            const sampleY = frameStartY + (this.y - frameStartY) * sampleT;
            const sampleAngle = frameStartAngle + (this.spinAngle - frameStartAngle) * sampleT;
            this.trailSpawnTimer -= trailInterval;
            const prev = this.trail[this.trail.length - 1];
            if (prev) {
              const dx = prev.x - sampleX;
              const dy = prev.y - sampleY;
              const da = Math.abs(prev.angle - sampleAngle);
              if (dx * dx + dy * dy < PLAYER_CFG.trailPositionThresholdSq && da < PLAYER_CFG.trailAngleThreshold) {
                continue;
              }
            }
            this.trail.push({
              x: sampleX,
              y: sampleY,
              angle: sampleAngle,
              age: 0,
              life: this.action.type === "dodge" ? PLAYER_CFG.dodgeTrailLife : PLAYER_CFG.chargedTrailLife,
              alpha: this.action.type === "dodge" ? PLAYER_CFG.dodgeTrailAlpha : PLAYER_CFG.chargedTrailAlpha
            });
            if (this.trail.length > PLAYER_CFG.maxTrailSamples) {
              this.trail.shift();
            }
          }

          if (this.action.elapsed >= this.action.duration) {
            this.action = null;
            this.vx = 0;
            this.vy = 0;
            this.spinAngle = 0;
          }
        }
      }

      applyPostActionDamping(dt) {
        if (this.action) {
          return;
        }
        this.vx *= Math.max(0, 1 - dt * PLAYER_CFG.idleDampingRate);
        this.vy *= Math.max(0, 1 - dt * PLAYER_CFG.idleDampingRate);
        this.spinAngle = 0;
      }

      applyMovement(dt) {
        if (!this.action || this.action.type !== "charged") {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
        }
      }

      drawTrail(ctx, now) {
        ctx.save();
        for (let i = 0; i < this.trail.length; i += 1) {
          const t = this.trail[i];
          const alpha = (1 - t.age / t.life) * t.alpha;
          const floatOffset = Math.sin((now - t.age * 1000) * 0.003) * 2;
          ctx.globalAlpha = alpha;
          ctx.translate(t.x, t.y);
          ctx.rotate(t.angle);
          ctx.drawImage(EMOJI_CANVASES.player, -EMOJI_CANVASES.player.width / 2, -EMOJI_CANVASES.player.height / 2 + 4 + floatOffset);
          ctx.rotate(-t.angle);
          ctx.translate(-t.x, -t.y);
        }
        ctx.restore();
      }

      drawActionRing(ctx) {
        if (this.action && this.action.type === "charged") {
          const ringScale = 1.1;
          const ringLineWidth = 5 * ringScale * 1.3;
          const ringOuterRadius = this.height * 0.5 * ringScale;
          const ringRadius = ringOuterRadius - ringLineWidth * 0.5;
          ctx.save();
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = ringLineWidth;
          ctx.beginPath();
          ctx.arc(this.x, this.y, ringRadius, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }
      }

      drawShadow(ctx) {
        const shadowY = this.y + this.height * 0.5 - 0.5;
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.14)";
        ctx.beginPath();
        ctx.ellipse(this.x, shadowY, this.width * 1.2, 3.5, 0, 0, TAU);
        ctx.fill();
        ctx.fillStyle = "rgba(0, 0, 0, 0.07)";
        ctx.beginPath();
        ctx.ellipse(this.x, shadowY + 0.2, this.width * 1.6, 5.0, 0, 0, TAU);
        ctx.fill();
        ctx.restore();
      }

      drawSprite(ctx, now) {
        if (this.hitFlashTimer > 0 && Math.sin(now * 0.03) > 0) return;
        const floatOffset = Math.sin(now * 0.003) * 2;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.spinAngle);
        ctx.drawImage(EMOJI_CANVASES.player, -EMOJI_CANVASES.player.width / 2, -EMOJI_CANVASES.player.height / 2 + 4 + floatOffset);
        ctx.restore();
      }

      drawChargeBar(ctx) {
        if (this.chargeVisible && !this.action) {
          const ringScale = 1.1;
          const chargeBarLineWidth = 3 * 1.3;
          const chargeBarOuterRadius = this.height * 0.5 * ringScale;
          const chargeBarRadius = chargeBarOuterRadius - chargeBarLineWidth * 0.5;
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.lineWidth = chargeBarLineWidth;
          ctx.strokeStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(0, 0, chargeBarRadius, -Math.PI / 2, -Math.PI / 2 + TAU * this.chargeProgress);
          ctx.stroke();
          ctx.restore();
        }
      }

      draw(ctx) {
        const now = performance.now();
        this.drawTrail(ctx, now);
        this.drawActionRing(ctx);
        this.drawShadow(ctx);
        this.drawSprite(ctx, now);
        this.drawChargeBar(ctx);
      }
    }

    class BaseEnemy extends Entity {
      constructor(x, y, emojiKey) {
        super(x, y, ENEMY_CFG.width, ENEMY_CFG.height);
        this.emojiCanvas = EMOJI_CANVASES[emojiKey] || EMOJI_CANVASES.rat;
        this.prevX = x;
        this.prevY = y;
        this.prevRollAngle = 0;
        this.renderX = x;
        this.renderY = y;
        this.renderRollAngle = 0;
        this.entering = false;
        this.knockbackVX = 0;
        this.knockbackVY = 0;

        this.hitRadius = ENEMY_CFG.hitRadius;

        this.maxHealth = ENEMY_CFG.maxHealth;
        this.health = this.maxHealth;
        this.displayHealth = this.maxHealth;
        this.alive = true;

        this.state = ENEMY_STATES.STALK;
        this.chargeTriggerDistance = ENEMY_CFG.chargeTriggerDistance;
        this.windupDuration = ENEMY_CFG.windupDuration;
        this.chargeDuration = ENEMY_CFG.chargeDuration;
        this.recoverDuration = ENEMY_CFG.recoverDuration;
        this.postAttackCooldownDuration = ENEMY_CFG.postAttackCooldownDuration;
        this.windupTimer = 0;
        this.chargeTimer = 0;
        this.recoverTimer = 0;
        this.postAttackCooldownTimer = 0;
        this.chargeDirection = { x: 0, y: 0 };

        this.stalkSpeed = ENEMY_CFG.stalkSpeed;
        this.chargeSpeed = ENEMY_CFG.chargeSpeed;
        this.waddleTime = 0;
        this.hitCooldown = 0;
        this.hitFlashTimer = 0;
        this.stunTimer = 0;
        this.stunDuration = ENEMY_CFG.stunDuration;
        this.lastHitByActionId = null;
        this.rollAngle = 0;
        this.baseChargeSpinAmount = ENEMY_CFG.chargeSpinAmount;
        this.chargeSpinAmount = 0;
        this.chargeElapsed = 0;
        
        this.flankDir = Math.random() < 0.5 ? 1 : -1;
        this.flankTimer = Math.random() * TAU;
        this.flankFreq = 0.3 + Math.random() * 0.5;
        this.flankAmplitude = 0.3 + Math.random() * 0.4;
      }

      update(dt, player, game) {
        if (!this.alive) {
          return;
        }

        this.cachePreviousTransform();
        this.updateTimers(dt);
        this.ageTrail(dt);

        const toPlayer = Vec2.sub({ x: player.x, y: player.y }, { x: this.x, y: this.y });
        const playerDistance = Vec2.length(toPlayer);
        const toPlayerDir = playerDistance > EPSILON ? Vec2.mul(toPlayer, 1 / playerDistance) : { x: 0, y: 0 };

        this.updateState(dt, playerDistance, toPlayerDir, game);
        this.applyKnockbackDamping(dt);
        this.integratePosition(dt);
        this.clampToPlayfield();
      }

      cachePreviousTransform() {
        this.prevX = this.x;
        this.prevY = this.y;
        this.prevRollAngle = this.rollAngle;
      }

      updateTimers(dt) {
        this.waddleTime += dt;
        this.hitCooldown = Math.max(0, this.hitCooldown - dt);
        this.hitFlashTimer = Math.max(0, this.hitFlashTimer - dt);
        this.stunTimer = Math.max(0, this.stunTimer - dt);
        this.postAttackCooldownTimer = Math.max(0, this.postAttackCooldownTimer - dt);
        if (this.displayHealth > this.health) {
          this.displayHealth = Math.max(this.health, this.displayHealth - dt * 2.5);
        }
      }

      getStateHandlers() {
        return {
          [ENEMY_STATES.STALK]: (dt, playerDistance, toPlayerDir, game) => {
            this.flankTimer += dt;
            let targetDirX = toPlayerDir.x;
            let targetDirY = toPlayerDir.y;
            
            if (playerDistance > this.chargeTriggerDistance) {
              const flankAngle = Math.sin(this.flankTimer * this.flankFreq) * this.flankAmplitude * this.flankDir;
              const cosA = Math.cos(flankAngle);
              const sinA = Math.sin(flankAngle);
              targetDirX = toPlayerDir.x * cosA - toPlayerDir.y * sinA;
              targetDirY = toPlayerDir.x * sinA + toPlayerDir.y * cosA;
            }
            
            this.updateStalkState(dt, playerDistance, { x: targetDirX, y: targetDirY }, game);
            
            let repX = 0;
            let repY = 0;
            let separated = false;
            for (let i = 0; i < game.enemies.length; i++) {
              const other = game.enemies[i];
              if (other !== this && other.alive && !other.entering) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const distSq = dx * dx + dy * dy;
                if (distSq > 0 && distSq < ENEMY_CFG.separationRadiusSq) {
                  const dist = Math.sqrt(distSq);
                  repX += (dx / dist) * (ENEMY_CFG.separationForce - dist);
                  repY += (dy / dist) * (ENEMY_CFG.separationForce - dist);
                  separated = true;
                }
              }
            }
            if (separated) {
              const currentV = { x: this.vx, y: this.vy };
              const repDir = Vec2.normalize({ x: repX, y: repY });
              const speed = Vec2.length(currentV) || this.stalkSpeed;
              const blendedX = currentV.x * 0.7 + repDir.x * speed * 0.3;
              const blendedY = currentV.y * 0.7 + repDir.y * speed * 0.3;
              const blended = Vec2.normalize({ x: blendedX, y: blendedY });
              this.vx = blended.x * speed;
              this.vy = blended.y * speed;
            }
          },
          [ENEMY_STATES.WINDUP]: (dt) => this.updateWindupState(dt),
          [ENEMY_STATES.CHARGE]: (dt, pd, td, game) => this.updateChargeState(dt, game),
          [ENEMY_STATES.RECOVER]: (dt) => this.updateRecoverState(dt)
        };
      }

      updateState(dt, playerDistance, toPlayerDir, game) {
        if (this.stunTimer > 0) {
          this.vx = 0;
          this.vy = 0;
          this.rollAngle = 0;
          return;
        }

        if (this.entering) {
          this.vx = (this.x < GAME_WIDTH * 0.5 ? 1 : -1) * this.stalkSpeed;
          this.vy = 0;
          this.rollAngle = 0;
          return;
        }

        const handler = this.getStateHandlers()[this.state];
        if (handler) {
          handler(dt, playerDistance, toPlayerDir, game);
        }
      }

      updateStalkState(dt, playerDistance, toPlayerDir) {
        this.vx = toPlayerDir.x * this.stalkSpeed;
        this.vy = toPlayerDir.y * this.stalkSpeed;
        this.rollAngle = 0;
        if (playerDistance <= this.chargeTriggerDistance && this.postAttackCooldownTimer <= 0) {
          this.state = ENEMY_STATES.WINDUP;
          this.windupTimer = this.windupDuration;
          this.chargeDirection = toPlayerDir;
          if (Vec2.length(this.chargeDirection) <= EPSILON) {
            this.chargeDirection = { x: ENEMY_CFG.defaultChargeDirection.x, y: ENEMY_CFG.defaultChargeDirection.y };
          }
          this.vx = 0;
          this.vy = 0;
        }
      }

      updateWindupState(dt) {
        this.vx = 0;
        this.vy = 0;
        this.rollAngle = 0;
        this.windupTimer -= dt;
        if (this.windupTimer <= 0) {
          this.state = ENEMY_STATES.CHARGE;
          this.chargeTimer = this.chargeDuration;
          this.chargeElapsed = 0;
          const spinSign = this.chargeDirection.x >= 0 ? 1 : -1;
          this.chargeSpinAmount = this.baseChargeSpinAmount * spinSign;
        }
      }

      updateChargeState(dt, game) {
        this.vx = this.chargeDirection.x * this.chargeSpeed;
        this.vy = this.chargeDirection.y * this.chargeSpeed;
        this.chargeElapsed += dt;
        const chargeT = clamp(this.chargeElapsed / this.chargeDuration, 0, 1);
        this.rollAngle = this.chargeSpinAmount * easeOutCubic(chargeT);
        this.spawnChargeTrail(dt);
        this.chargeTimer -= dt;
        if (this.chargeTimer <= 0) {
          this.state = ENEMY_STATES.RECOVER;
          this.recoverTimer = this.recoverDuration;
          this.postAttackCooldownTimer = this.postAttackCooldownDuration;
        }
      }

      spawnChargeTrail(dt) {
        this.spawnTrailSamples(
          dt,
          ENEMY_CFG.chargeTrailInterval,
          ENEMY_CFG.chargeTrailLife,
          ENEMY_CFG.chargeTrailAlpha,
          ENEMY_CFG.maxTrailSamples,
          { x: this.x, y: this.y, angle: this.rollAngle }
        );
      }

      updateRecoverState(dt) {
        const damp = Math.max(0, 1 - dt * ENEMY_CFG.recoverDampingRate);
        this.vx *= damp;
        this.vy *= damp;
        this.rollAngle = 0;
        this.recoverTimer -= dt;
        if (this.recoverTimer <= 0) {
          this.state = ENEMY_STATES.STALK;
        }
      }

      applyKnockbackDamping(dt) {
        const knockbackDamp = Math.max(0, 1 - dt * ENEMY_CFG.knockbackDampingRate);
        this.knockbackVX *= knockbackDamp;
        this.knockbackVY *= knockbackDamp;
      }

      integratePosition(dt) {
        this.x += (this.vx + this.knockbackVX) * dt;
        this.y += (this.vy + this.knockbackVY) * dt;
      }

      clampToPlayfield() {
        const halfW = this.width * 0.5;
        if (this.entering) {
          if (this.x >= halfW && this.x <= GAME_WIDTH - halfW) {
            this.entering = false;
          }
        }
        
        if (this.entering) {
          if (this.x < GAME_WIDTH * 0.5) {
            this.x = Math.max(this.x, this.prevX);
            this.knockbackVX = Math.max(0, this.knockbackVX);
          } else {
            this.x = Math.min(this.x, this.prevX);
            this.knockbackVX = Math.min(0, this.knockbackVX);
          }
          // Clamp vertically manually while entering
          this.y = clamp(this.y, this.height * 0.5, GAME_HEIGHT - this.height * 0.5);
        } else {
          super.clampToPlayfield();
        }
      }

      isOverlappingPlayer(player) {
        const combatReach = Math.max(player.width, player.height) * ENEMY_CFG.combatReachPlayerFactor + this.hitRadius;
        return MathUtils.distanceSq(this.x, this.y, player.x, player.y) <= combatReach * combatReach;
      }

      onPlayerContact(player, game) {
        if (!this.canReceiveChargedHit(player)) {
          return;
        }

        const awayFromHit = this.getAwayFromHitDirection(player);
        this.applyChargedHit(player, awayFromHit);
        const hitX = (this.x + player.x) * 0.5;
        const hitY = (this.y + player.y) * 0.5;
        this.spawnChargedHitEffects(game, hitX, hitY, awayFromHit);

        if (this.health <= 0) {
          this.handleDeath(game);
        }
      }

      canReceiveChargedHit(player) {
        if (!this.alive || !player.action || !this.isOverlappingPlayer(player)) {
          return false;
        }
        if (player.action.type === "dodge") {
          return false;
        }
        if (player.action.type !== "charged" || this.hitCooldown > 0) {
          return false;
        }
        if (this.lastHitByActionId === player.action.id) {
          return false;
        }
        return true;
      }

      getAwayFromHitDirection(player) {
        let awayFromHit = Vec2.sub({ x: this.x, y: this.y }, { x: player.x, y: player.y });
        awayFromHit = Vec2.normalize(awayFromHit);
        if (Vec2.length(awayFromHit) <= EPSILON) {
          return player.action.direction || { x: ENEMY_CFG.defaultChargeDirection.x, y: ENEMY_CFG.defaultChargeDirection.y };
        }
        return awayFromHit;
      }

      applyChargedHit(player, awayFromHit) {
        this.health = Math.max(0, this.health - 1);
        this.lastHitByActionId = player.action.id;
        this.hitFlashTimer = ENEMY_CFG.hitFlashDuration;
        this.hitCooldown = ENEMY_CFG.hitCooldownDuration;
        this.stunTimer = this.stunDuration;
        this.state = ENEMY_STATES.RECOVER;
        this.recoverTimer = this.recoverDuration;
        this.knockbackVX += awayFromHit.x * ENEMY_CFG.knockbackImpulse;
        this.knockbackVY += awayFromHit.y * ENEMY_CFG.knockbackImpulse;
      }

      spawnChargedHitEffects(game, hitX, hitY, awayFromHit) {
        game.particles.emit(hitX, hitY, FX_CFG.hitParticleCount, {
          baseAngle: Math.atan2(awayFromHit.y, awayFromHit.x),
          spread: FX_CFG.hitParticleSpread,
          minSpeed: FX_CFG.hitParticleMinSpeed,
          maxSpeed: FX_CFG.hitParticleMaxSpeed,
          minLife: FX_CFG.hitParticleMinLife,
          maxLife: FX_CFG.hitParticleMaxLife,
          minSize: FX_CFG.hitParticleMinSize,
          maxSize: FX_CFG.hitParticleMaxSize,
          colors: FX_CFG.hitParticleColors,
          drag: FX_CFG.hitParticleDrag
        });

        game.flashRings.push({
          x: hitX, y: hitY,
          maxRadius: FX_CFG.hitRingRadius,
          age: 0,
          life: FX_CFG.hitRingLife,
          type: "shockwave"
        });

        game.triggerShake(FX_CFG.hitShake.intensity, FX_CFG.hitShake.duration);
        game.triggerHitstop(FX_CFG.hitstopDuration);
        game.triggerTimeSlow(FX_CFG.hitTimeSlow.duration, FX_CFG.hitTimeSlow.minScale);
      }

      handleDeath(game) {
        this.alive = false;

        game.triggerShake(FX_CFG.deathShake.intensity, FX_CFG.deathShake.duration);
        game.triggerHitstop(FX_CFG.deathHitstopDuration);
        game.triggerTimeSlow(FX_CFG.deathTimeSlow.duration, FX_CFG.deathTimeSlow.minScale);

        game.flashRings.push({
          x: this.x, y: this.y,
          maxRadius: FX_CFG.deathRingRadius,
          age: 0,
          life: FX_CFG.deathRingLife,
          type: "deathFlash"
        });

        game.particles.emit(this.x, this.y, FX_CFG.deathParticleCount, {
          baseAngle: 0,
          spread: TAU,
          minSpeed: FX_CFG.deathParticleMinSpeed,
          maxSpeed: FX_CFG.deathParticleMaxSpeed,
          minLife: FX_CFG.deathParticleMinLife,
          maxLife: FX_CFG.deathParticleMaxLife,
          minSize: FX_CFG.deathParticleMinSize,
          maxSize: FX_CFG.deathParticleMaxSize,
          colors: FX_CFG.deathParticleColors,
          drag: FX_CFG.deathParticleDrag
        });

        game.rainbowParticles.emit(this.x, this.y, FX_CFG.rainbowMinCount + Math.floor(Math.random() * FX_CFG.rainbowExtraCount));
      }

      checkDamageToPlayer(player, game) {
        if (!this.alive || this.state !== "charge") return;
        if (player.iframeTimer > 0 || player.health <= 0) return;
        if (player.action && (player.action.type === "dodge" || player.action.type === "charged")) return;
        if (!this.isOverlappingPlayer(player)) return;
        player.takeDamage(game);
      }

      interpolate(alpha) {
        this.renderX = this.prevX + (this.x - this.prevX) * alpha;
        this.renderY = this.prevY + (this.y - this.prevY) * alpha;
        this.renderRollAngle = this.prevRollAngle + (this.rollAngle - this.prevRollAngle) * alpha;
      }

      draw(ctx, nowSeconds) {
        if (!this.alive) {
          return;
        }

        const rx = this.renderX;
        const ry = this.renderY;
        const rAngle = this.renderRollAngle;

        ctx.save();
        for (let i = 0; i < this.trail.length; i += 1) {
          const t = this.trail[i];
          const alpha = (1 - t.age / t.life) * t.alpha;
          ctx.globalAlpha = alpha;
          ctx.translate(t.x, t.y);
          ctx.rotate(t.angle);
          ctx.drawImage(this.emojiCanvas, -this.emojiCanvas.width / 2, -this.emojiCanvas.height / 2);
          ctx.rotate(-t.angle);
          ctx.translate(-t.x, -t.y);
        }
        ctx.restore();

        const shadowY = ry + this.height * 0.35 - 3.5 + (this.shadowOffsetY || 0);
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.14)";
        ctx.beginPath();
        ctx.ellipse(rx, shadowY, this.width * 0.5, 2.2, 0, 0, TAU);
        ctx.fill();
        ctx.fillStyle = "rgba(0, 0, 0, 0.07)";
        ctx.beginPath();
        ctx.ellipse(rx, shadowY + 0.2, this.width * 0.7, 3.2, 0, 0, TAU);
        ctx.fill();
        ctx.restore();

        let waddle = 0;
        if (this.state === "stalk" || this.state === "recover") {
          waddle = Math.sin(this.waddleTime * 12) * 0.12;
        }

        ctx.save();
        if (this.hitFlashTimer > 0) {
          ctx.globalAlpha = 0.5 + 0.5 * Math.sin(nowSeconds * 40);
        } else if (this.state === "windup") {
          const flashOn = Math.sin(nowSeconds * 36) > 0;
          ctx.globalAlpha = flashOn ? 0.4 : 1;
        }
        ctx.translate(rx, ry);
        ctx.rotate(waddle + rAngle);
        ctx.drawImage(this.emojiCanvas, -this.emojiCanvas.width / 2, -this.emojiCanvas.height / 2);
        ctx.restore();

        if (this.health < this.maxHealth && this.health > 0) {
          const hpFrac = this.health / this.maxHealth;
          const displayHpFrac = this.displayHealth / this.maxHealth;
          const barW = this.width * 1.2;
          const barH = 3;
          const barX = rx - barW * 0.5;
          const barY = ry - this.height * 0.5 - 15;
          
          ctx.save();
          ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
          ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
          
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(barX, barY, barW * displayHpFrac, barH);
          
          ctx.fillStyle = "#ff2222";
          ctx.fillRect(barX, barY, barW * hpFrac, barH);
          ctx.restore();
        }
      }
    }

    class RatEnemy extends BaseEnemy {
      constructor(x, y) {
        super(x, y, "rat");
        this.maxHealth = 4;
        this.health = this.maxHealth;
        this.displayHealth = this.maxHealth;
      }
    }

    class BatEnemy extends BaseEnemy {
      constructor(x, y) {
        super(x, y, "bat");
        this.stalkSpeed = ENEMY_CFG.stalkSpeed * 1.5;
        this.chargeTriggerDistance = ENEMY_CFG.chargeTriggerDistance * 1.2;
        this.windupDuration = 0.42;
        this.chargeDuration = ENEMY_CFG.chargeDuration * 0.8;
        this.recoverDuration = ENEMY_CFG.recoverDuration * 0.5;
        this.postAttackCooldownDuration = ENEMY_CFG.postAttackCooldownDuration * 1.3;
        this.chargeSpeed = ENEMY_CFG.chargeSpeed * 1.2;
        this.maxHealth = 2;
        this.health = this.maxHealth;
        this.displayHealth = this.maxHealth;
        this.sineTimer = Math.random() * TAU;
        this.sineFreq = 3 + Math.random() * 3;
        this.swoopCount = 0;
      }
      applyChargedHit(player, awayFromHit) {
        const inWindup = this.state === ENEMY_STATES.WINDUP;
        const last75Percent = this.windupTimer <= this.windupDuration * 0.75;
        
        if (inWindup && last75Percent) {
          this.health = Math.max(0, this.health - 1);
          this.lastHitByActionId = player.action.id;
          this.hitFlashTimer = ENEMY_CFG.hitFlashDuration;
          this.hitCooldown = ENEMY_CFG.hitCooldownDuration;
        } else {
          super.applyChargedHit(player, awayFromHit);
        }
      }
      updateChargeState(dt, game) {
        super.updateChargeState(dt, game);
        if (this.state === ENEMY_STATES.RECOVER) {
          if (this.swoopCount === 0) {
            this.swoopCount = 1;
            this.state = ENEMY_STATES.WINDUP;
            this.windupTimer = this.windupDuration;
            const toPlayer = Vec2.sub({ x: game.player.x, y: game.player.y }, { x: this.x, y: this.y });
            const dist = Vec2.length(toPlayer);
            this.chargeDirection = dist > EPSILON ? Vec2.mul(toPlayer, 1 / dist) : { x: 0, y: 1 };
          } else {
            this.swoopCount = 0;
          }
        }
      }
      updateStalkState(dt, playerDistance, toPlayerDir) {
        this.sineTimer += dt;
        const perp = { x: -toPlayerDir.y, y: toPlayerDir.x };
        const sway = Math.sin(this.sineTimer * this.sineFreq) * 0.5;
        const moveDir = Vec2.normalize(Vec2.add(toPlayerDir, Vec2.mul(perp, sway)));
        this.vx = moveDir.x * this.stalkSpeed;
        this.vy = moveDir.y * this.stalkSpeed;
        this.rollAngle = sway * 0.5;
        
        if (playerDistance <= this.chargeTriggerDistance && this.postAttackCooldownTimer <= 0) {
          this.state = ENEMY_STATES.WINDUP;
          this.windupTimer = this.windupDuration;
          this.chargeDirection = toPlayerDir;
          if (Vec2.length(this.chargeDirection) <= EPSILON) {
            this.chargeDirection = { x: 0, y: 1 };
          }
          this.vx = 0;
          this.vy = 0;
        }
      }
    }

    class SnakeEnemy extends BaseEnemy {
      constructor(x, y) {
        super(x, y, "snake");
        this.width = ENEMY_CFG.width * 2;
        this.height = ENEMY_CFG.height * 2;
        this.hitRadius = ENEMY_CFG.hitRadius * 2;
        this.maxHealth = 6;
        this.health = this.maxHealth;
        this.displayHealth = this.maxHealth;
        this.stalkSpeed = ENEMY_CFG.stalkSpeed * 0.8;
        this.chargeTriggerDistance = 300;
        this.maintainDistance = 100;
        this.windupDuration = ENEMY_CFG.windupDuration * 1.2;
        this.minFireCooldown = 1;
        this.maxFireCooldown = 2.5;
        this.shadowOffsetY = 10;
      }
      applyChargedHit(player, awayFromHit) {
        const inWindup = this.state === ENEMY_STATES.WINDUP;
        const last75Percent = this.windupTimer <= this.windupDuration * 0.75;
        
        if (inWindup && last75Percent) {
          this.health = Math.max(0, this.health - 1);
          this.lastHitByActionId = player.action.id;
          this.hitFlashTimer = ENEMY_CFG.hitFlashDuration;
          this.hitCooldown = ENEMY_CFG.hitCooldownDuration;
        } else {
          super.applyChargedHit(player, awayFromHit);
        }
      }
      updateStalkState(dt, playerDistance, toPlayerDir) {
        if (playerDistance < this.maintainDistance) {
          this.vx = -toPlayerDir.x * this.stalkSpeed;
          this.vy = -toPlayerDir.y * this.stalkSpeed;
        } else if (playerDistance > this.maintainDistance + 20) {
          this.vx = toPlayerDir.x * this.stalkSpeed;
          this.vy = toPlayerDir.y * this.stalkSpeed;
        } else {
          this.vx = 0;
          this.vy = 0;
        }
        this.rollAngle = 0;
        
        if (playerDistance <= this.chargeTriggerDistance && this.postAttackCooldownTimer <= 0) {
          this.state = ENEMY_STATES.WINDUP;
          this.windupTimer = this.windupDuration;
          this.chargeDirection = toPlayerDir;
          if (Vec2.length(this.chargeDirection) <= EPSILON) {
            this.chargeDirection = { x: 0, y: 1 };
          }
          this.vx = 0;
          this.vy = 0;
        }
      }
      updateChargeState(dt, game) {
        if (this.state === "charge") {
          const px = this.x + this.chargeDirection.x * 20;
          const py = this.y + this.chargeDirection.y * 20;
          game.projectiles.push(new Projectile(px, py, this.chargeDirection.x * PROJECTILE_CFG.speed, this.chargeDirection.y * PROJECTILE_CFG.speed));
          this.state = ENEMY_STATES.RECOVER;
          this.recoverTimer = this.recoverDuration;
          this.postAttackCooldownTimer = this.minFireCooldown + Math.random() * (this.maxFireCooldown - this.minFireCooldown);
        }
      }
    }

    class SpiderEnemy extends BaseEnemy {
      constructor(x, y) {
        super(x, y, "spider");
        this.maxHealth = 2;
        this.health = this.maxHealth;
        this.displayHealth = this.maxHealth;
        this.isBursting = Math.random() < 0.5;
        this.burstTimer = Math.random() * 0.3;
        this.burstOnDuration = 0.2 + Math.random() * 0.2;
        this.burstOffDuration = 0.4 + Math.random() * 0.4;
        this.chargeTriggerDistance = 60;
        this.windupDuration = 0.42;
        this.chargeDuration = 0.075;
        this.chargeSpeed = ENEMY_CFG.chargeSpeed * 1.05;
        this.recoverDuration = 0.5;
        this.baseChargeSpinAmount = TAU;
      }
      updateStalkState(dt, playerDistance, toPlayerDir, game) {
        this.burstTimer -= dt;
        if (this.burstTimer <= 0) {
          this.isBursting = !this.isBursting;
          if (this.isBursting && playerDistance > this.chargeTriggerDistance && Math.random() < 0.2) {
            this.isBursting = false;
            this.burstTimer = this.burstOffDuration;
            this.vx = 0;
            this.vy = 0;
            if (game) {
              game.projectiles.push(new WebProjectile(this.x, this.y, game.player.x, game.player.y));
            }
          } else {
            this.burstTimer = this.isBursting ? this.burstOnDuration : this.burstOffDuration;
          }
        }
        
        if (this.isBursting) {
          this.vx = toPlayerDir.x * this.stalkSpeed * 3;
          this.vy = toPlayerDir.y * this.stalkSpeed * 3;
        } else {
          this.vx = 0;
          this.vy = 0;
        }
        this.rollAngle = 0;
        
        if (playerDistance <= this.chargeTriggerDistance && this.postAttackCooldownTimer <= 0) {
          this.state = ENEMY_STATES.WINDUP;
          this.windupTimer = this.windupDuration;
          this.chargeDirection = toPlayerDir;
          if (Vec2.length(this.chargeDirection) <= EPSILON) {
            this.chargeDirection = { x: 0, y: 1 };
          }
          this.vx = 0;
          this.vy = 0;
          this.isBursting = false;
          this.burstTimer = 0;
        }
      }
    }

    class BoarEnemy extends BaseEnemy {
      constructor(x, y) {
        super(x, y, "boar");
        this.width = ENEMY_CFG.width * 1.5;
        this.height = ENEMY_CFG.height * 1.5;
        this.hitRadius = ENEMY_CFG.hitRadius * 1.5;
        this.maxHealth = 6;
        this.health = this.maxHealth;
        this.displayHealth = this.maxHealth;
        this.stalkSpeed = ENEMY_CFG.stalkSpeed * 0.6;
        this.chargeTriggerDistance = 180;
        this.windupDuration = 1;
        this.chargeDuration = 0.8;
        this.chargeSpeed = ENEMY_CFG.chargeSpeed * 1.1;
        this.recoverDuration = 0.8;
        this.baseChargeSpinAmount = 0;
        this.shadowOffsetY = 4;
      }
      applyChargedHit(player, awayFromHit) {
        const inWindup = this.state === ENEMY_STATES.WINDUP;
        const last75Percent = this.windupTimer <= this.windupDuration * 0.75;
        
        if (inWindup && last75Percent) {
          this.health = Math.max(0, this.health - 1);
          this.lastHitByActionId = player.action.id;
          this.hitFlashTimer = ENEMY_CFG.hitFlashDuration;
          this.hitCooldown = ENEMY_CFG.hitCooldownDuration;
        } else {
          super.applyChargedHit(player, awayFromHit);
        }
      }
    }

    class Projectile extends Entity {
      constructor(x, y, vx, vy) {
        super(x, y, PROJECTILE_CFG.radius * 2, PROJECTILE_CFG.radius * 2);
        this.vx = vx;
        this.vy = vy;
        this.alive = true;
      }
      update(dt, game) {
        if (!this.alive) return;
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        const angle = Math.atan2(this.vy, this.vx) - Math.PI / 2;
        
        this.spawnTrailSamples(
          dt,
          PROJECTILE_CFG.trailInterval,
          PROJECTILE_CFG.trailLife,
          PROJECTILE_CFG.trailAlpha,
          PROJECTILE_CFG.maxTrailSamples,
          { x: this.x, y: this.y, angle: angle }
        );
        this.ageTrail(dt);
        
        if (this.alive && game.player.health > 0 && game.player.iframeTimer <= 0) {
          if (!game.player.action || game.player.action.type !== "dodge") {
            const distSq = MathUtils.distanceSq(this.x, this.y, game.player.x, game.player.y);
            const reach = (game.player.width + game.player.height) * 0.25 + PROJECTILE_CFG.radius;
            if (distSq <= reach * reach) {
              game.player.takeDamage(game);
              this.alive = false;
            }
          }
        }
        
        if (this.x < -50 || this.x > GAME_WIDTH + 50 || this.y < -50 || this.y > GAME_HEIGHT + 50) {
          this.alive = false;
        }
      }
      draw(ctx) {
        if (!this.alive) return;
        ctx.save();
        for (let i = 0; i < this.trail.length; i += 1) {
          const t = this.trail[i];
          const alpha = (1 - t.age / t.life) * t.alpha;
          ctx.globalAlpha = alpha;
          ctx.translate(t.x, t.y);
          ctx.rotate(t.angle);
          ctx.drawImage(EMOJI_CANVASES.drop, -EMOJI_CANVASES.drop.width / 2, -EMOJI_CANVASES.drop.height / 2);
          ctx.rotate(-t.angle);
          ctx.translate(-t.x, -t.y);
        }
        
        const currentAngle = Math.atan2(this.vy, this.vx) - Math.PI / 2;
        ctx.globalAlpha = 1;
        ctx.translate(this.x, this.y);
        ctx.rotate(currentAngle);
        ctx.drawImage(EMOJI_CANVASES.drop, -EMOJI_CANVASES.drop.width / 2, -EMOJI_CANVASES.drop.height / 2);
        ctx.restore();
      }
    }

    class WebProjectile extends Projectile {
      constructor(x, y, targetX, targetY) {
        super(x, y, 0, 0);
        this.startX = x;
        this.startY = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.speed = WEB_CFG.projectileSpeed;
        this.arriveRadius = PROJECTILE_CFG.radius;
        this.initialDistance = Math.sqrt(MathUtils.distanceSq(x, y, targetX, targetY));
        this.z = 0;
      }

      update(dt, game) {
        if (!this.alive) return;

        const toTarget = { x: this.targetX - this.x, y: this.targetY - this.y };
        const distance = Vec2.length(toTarget);
        if (distance <= this.arriveRadius) {
          this.land(game);
          return;
        }

        const dir = distance > EPSILON ? Vec2.mul(toTarget, 1 / distance) : { x: 0, y: 0 };
        this.vx = dir.x * this.speed;
        this.vy = dir.y * this.speed;
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        const currentDist = Math.sqrt(MathUtils.distanceSq(this.startX, this.startY, this.x, this.y));
        const progress = this.initialDistance > 0 ? Math.min(1, currentDist / this.initialDistance) : 1;
        
        const maxHeight = Math.min(150, this.initialDistance * 0.4);
        this.z = 4 * maxHeight * progress * (1 - progress);

        this.spawnTrailSamples(
          dt,
          PROJECTILE_CFG.trailInterval,
          PROJECTILE_CFG.trailLife,
          PROJECTILE_CFG.trailAlpha,
          PROJECTILE_CFG.maxTrailSamples,
          { x: this.x, y: this.y - this.z, angle: 0 }
        );
        this.ageTrail(dt);

        const remainingDist = Math.sqrt(MathUtils.distanceSq(this.x, this.y, this.targetX, this.targetY));
        if (remainingDist <= this.arriveRadius) {
          this.land(game);
        }
      }

      land(game) {
        this.alive = false;
        game.webs.push(new WebTrap(this.targetX, this.targetY));
      }

      draw(ctx) {
        if (!this.alive) return;
        ctx.save();
        for (let i = 0; i < this.trail.length; i += 1) {
          const t = this.trail[i];
          const alpha = (1 - t.age / t.life) * t.alpha;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(t.x, t.y, PROJECTILE_CFG.radius * 0.9, 0, TAU);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(this.x, this.y - this.z, PROJECTILE_CFG.radius, 0, TAU);
        ctx.fill();
        ctx.restore();
      }
    }

    class WebTrap {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = WEB_CFG.trapRadius;
        this.life = WEB_CFG.trapLifetime;
        this.age = 0;
      }

      update(dt) {
        this.age += dt;
      }

      get expired() {
        return this.age >= this.life + WEB_CFG.trapFadeTime;
      }

      contains(x, y) {
        return MathUtils.distanceSq(this.x, this.y, x, y) <= this.radius * this.radius;
      }

      draw(ctx) {
        let alpha = 1;
        if (this.age > this.life) {
          alpha = clamp(1 - (this.age - this.life) / WEB_CFG.trapFadeTime, 0, 1);
        }
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.x, this.y);
        ctx.drawImage(EMOJI_CANVASES.web, -EMOJI_CANVASES.web.width / 2, -EMOJI_CANVASES.web.height / 2);
        ctx.restore();
      }
    }

    class LevelManager {
      constructor(game) {
        this.game = game;
        this.currentLevel = 0;
        this.currentWave = 0;
        this.waveTimer = 0;
        this.active = false;
        this.state = "playing"; // playing, completeDelay, waitingForInput
        this.stateTimer = 0;
        
        this.levels = [
          { svg: LEVEL_BACKGROUNDS.GRASS, waves: [] },
          { 
            svg: LEVEL_BACKGROUNDS.DIRT, 
            waves: [
              { delay: 1, enemies: ["rat", "bat"] },
              { delay: 8, enemies: ["bat", "bat", "bat"] },
              { delay: 14, enemies: ["bat", "bat", "bat", "rat", "rat"] }
            ] 
          },
          { 
            svg: LEVEL_BACKGROUNDS.SAND, 
            waves: [
              { delay: 1, enemies: ["snake"] },
              { delay: 6, enemies: ["snake", "snake", "rat"] },
              { delay: 20, enemies: ["snake", "rat", "rat", "rat", "bat"] },
              { delay: 26, enemies: ["snake", "snake", "rat", "rat", "bat", "bat"] }
            ] 
          },
          { 
            svg: LEVEL_BACKGROUNDS.STONE, 
            waves: [
              { delay: 1, enemies: ["spider", "spider"] },
              { delay: 8, enemies: ["spider", "spider", "spider", "snake"] },
              { delay: 16, enemies: ["spider", "spider", "spider", "spider", "bat", "bat"] },
              { delay: 20, enemies: ["spider", "spider", "spider", "spider"] },
              { delay: 6, enemies: ["snake", "snake", "bat", "bat"] }
            ] 
          },
          { 
            svg: LEVEL_BACKGROUNDS.SWAMP, 
            waves: [
              { delay: 1, enemies: ["spider", "spider", "bat", "bat"] },
              { delay: 10, enemies: ["boar", "snake"] },
              { delay: 12, enemies: ["boar", "boar", "boar"] },
              { delay: 20, enemies: ["boar", "boar", "spider", "snake", "snake"] },
              { delay: 40, enemies: ["boar", "spider"] },
              { delay: 2, enemies: ["boar", "snake"] },
              { delay: 2, enemies: ["spider", "bat"] },
              { delay: 2, enemies: ["snake", "bat"] },
              { delay: 10, enemies: ["boar", "boar"] }
            ] 
          }
        ];
      }
      
      start() {
        this.active = true;
        this.currentLevel = 1;
        this.startLevel();
      }
      
      startLevel() {
        this.state = "playing";
        this.currentWave = 0;
        this.waveTimer = this.levels[this.currentLevel].waves[this.currentWave].delay;
        this.game.setBackground(this.levels[this.currentLevel].svg);
        
        const select = document.getElementById("levelSelect");
        if (select && select.value !== this.currentLevel.toString()) {
          select.value = this.currentLevel;
        }
      }
      
      update(dt) {
        if (!this.active) return;
        
        if (this.state === "playing") {
          this.waveTimer -= dt;
          if (this.waveTimer <= 0) {
            this.spawnWave();
            this.currentWave++;
            if (this.currentWave < this.levels[this.currentLevel].waves.length) {
              this.waveTimer = this.levels[this.currentLevel].waves[this.currentWave].delay;
            } else {
              this.waveTimer = Infinity; 
            }
          }
          
          if (this.currentWave >= this.levels[this.currentLevel].waves.length) {
            const allDead = this.game.enemies.length > 0 && this.game.enemies.every(e => !e.alive);
            if (allDead) {
              this.state = "completeDelay";
              this.stateTimer = 1.0;
            }
          } else {
            const allDead = this.game.enemies.length > 0 && this.game.enemies.every(e => !e.alive);
            if (allDead && this.waveTimer > 1.0) {
              this.waveTimer = 1.0;
            }
          }
        } else if (this.state === "completeDelay") {
          this.stateTimer -= dt;
          if (this.stateTimer <= 0) {
            this.state = "waitingForInput";
            this.game.input.down = false;
            this.game.input.pendingSwipe = null;
          }
        } else if (this.state === "waitingForInput") {
          if (this.game.input.down || this.game.input.pendingSwipe) {
            this.game.input.down = false;
            this.game.input.pendingSwipe = null;
            
            // Clear particles
            this.game.clearLevelState();
            
            this.currentLevel++;
            if (this.currentLevel < this.levels.length) {
              this.startLevel();
            } else {
              this.active = false;
            }
          }
        }
      }
      
      spawnWave() {
        const wave = this.levels[this.currentLevel].waves[this.currentWave];
        wave.enemies.forEach(type => {
          this.game.spawnEnemy(type);
        });
      }
    }

    class Pool {
      constructor(factory, initialSize) {
        this.factory = factory;
        this.items = [];
        for (let i = 0; i < initialSize; i++) {
          this.items.push(this.factory());
        }
      }
      get() {
        return this.items.length > 0 ? this.items.pop() : this.factory();
      }
      release(item) {
        this.items.push(item);
      }
    }

    class ParticleSystem {
      constructor() {
        this.particles = [];
        this.pool = new Pool(() => ({
          x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, size: 0, color: "", drag: 0
        }), 200);
      }

      emit(x, y, count, config) {
        for (let i = 0; i < count; i++) {
          const angle = config.baseAngle + (Math.random() - 0.5) * config.spread;
          const speed = config.minSpeed + Math.random() * (config.maxSpeed - config.minSpeed);
          const life = config.minLife + Math.random() * (config.maxLife - config.minLife);
          const size = config.minSize + Math.random() * (config.maxSize - config.minSize);
          
          const p = this.pool.get();
          p.x = x;
          p.y = y;
          p.vx = Math.cos(angle) * speed;
          p.vy = Math.sin(angle) * speed;
          p.life = life;
          p.maxLife = life;
          p.size = size;
          p.color = config.colors[Math.floor(Math.random() * config.colors.length)];
          p.drag = config.drag || 0;
          this.particles.push(p);
        }
      }

      update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];
          if (p.drag > 0) {
            const damp = Math.max(0, 1 - dt * p.drag);
            p.vx *= damp;
            p.vy *= damp;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.life -= dt;
          if (p.life <= 0) {
            this.pool.release(p);
            MathUtils.swapAndPop(this.particles, i);
          }
        }
      }

      draw(ctx) {
        ctx.save();
        for (let i = 0; i < this.particles.length; i++) {
          const p = this.particles[i];
          const t = p.life / p.maxLife;
          const currentSize = p.size * (0.3 + 0.7 * t);
          ctx.globalAlpha = t * t;
          ctx.fillStyle = p.color;
          ctx.translate(p.x, p.y);
          const angle = Math.atan2(p.vy, p.vx);
          ctx.rotate(angle);
          ctx.fillRect(-currentSize * 0.5, -currentSize * 0.3, currentSize, currentSize * 0.6);
          ctx.rotate(-angle);
          ctx.translate(-p.x, -p.y);
        }
        ctx.restore();
      }
    }

    class RainbowDeathParticleSystem {
      constructor() {
        this.particles = [];
        this.pool = new Pool(() => ({
          x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, r: 0, g: 0, b: 0, size: 0, gravity: 0, bounciness: 0, drag: 0
        }), 200);
      }

      emit(x, y, count) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * TAU;
          const speed = Math.random() * RAINBOW_CFG.speed;
          const hue = Math.random() * 360;
          const color = hslToRgb(hue, 100, 50);
          
          const p = this.pool.get();
          p.x = x;
          p.y = y;
          p.z = 0;
          p.vx = Math.cos(angle) * speed;
          p.vy = Math.sin(angle) * speed;
          p.vz = RAINBOW_CFG.zBase + Math.random() * RAINBOW_CFG.zRand;
          p.r = color.r;
          p.g = color.g;
          p.b = color.b;
          p.size = RAINBOW_CFG.sizeBase + Math.random() * RAINBOW_CFG.sizeRand;
          p.gravity = RAINBOW_CFG.gravity;
          p.bounciness = RAINBOW_CFG.bouncinessBase + Math.random() * RAINBOW_CFG.bouncinessRand;
          p.drag = RAINBOW_CFG.drag;
          this.particles.push(p);
        }
      }

      update(dt, player, groundSplotches) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];

          p.vz -= p.gravity * dt;

          const damp = Math.max(0, 1 - p.drag * dt);
          p.vx *= damp;
          p.vy *= damp;

          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.z += p.vz * dt;

          if (p.x < 0) { p.x = -p.x; p.vx = Math.abs(p.vx) * p.bounciness; }
          else if (p.x > GAME_WIDTH) { p.x = 2 * GAME_WIDTH - p.x; p.vx = -Math.abs(p.vx) * p.bounciness; }
          if (p.y < 0) { p.y = -p.y; p.vy = Math.abs(p.vy) * p.bounciness; }
          else if (p.y > GAME_HEIGHT) { p.y = 2 * GAME_HEIGHT - p.y; p.vy = -Math.abs(p.vy) * p.bounciness; }

          if (p.z <= 0 && p.vz < 0) {
            groundSplotches.push({
              x: p.x, y: p.y,
              r: p.r, g: p.g, b: p.b,
              radius: p.size * (1.5 + Math.random() * 1.5),
              alpha: 0.0875 + Math.random() * 0.0375
            });
            this.pool.release(p);
            MathUtils.swapAndPop(this.particles, i);
          }
        }
      }

      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = RAINBOW_CFG.globalAlpha;
        for (let i = 0; i < this.particles.length; i++) {
          const p = this.particles[i];
          const visualY = p.y - p.z * RAINBOW_CFG.visualYOffset;
          const scale = 1 + p.z * RAINBOW_CFG.scaleMult;
          const currentSize = p.size * scale;
          ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
          ctx.beginPath();
          ctx.arc(p.x, visualY, currentSize, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    class Tutorial {
      constructor(game) {
        this.game = game;
        this.phase = TUTORIAL_PHASES.INTRO;
        this.phaseTime = 0;
        this.dodgeSlowMoTrigger = TUTORIAL_CFG.dodgeSlowMoTrigger;
        this.tutorialTimeScale = 1;
        this.textAlpha = 0;
        this.fingerAnimTime = 0;
        this.active = true;
        this.attackDir = { x: 0, y: -1 };
        this.crawlScale = TUTORIAL_CFG.crawlScale;
        this.crawlDuration = TUTORIAL_CFG.crawlDuration;
        this.slowDropRate = TUTORIAL_CFG.slowDropRate;
        this.chainSpawnRemaining = 0;
        this.chainSpawnDelay = TUTORIAL_CFG.chainSpawnDelay;
        this.chainSpawnTimer = 0;
      }

      setPhase(newPhase) {
        this.phase = newPhase;
        this.phaseTime = 0;
        this.fingerAnimTime = 0;
        this.textAlpha = 0;
      }

      getPhaseHandlers() {
        return {
          [TUTORIAL_PHASES.INTRO]: (dt, player, enemy, input) => this.handleIntro(enemy, input),
          [TUTORIAL_PHASES.WAIT_DODGE]: (dt, player, enemy, input) => this.handleWaitDodge(dt, player, input),
          [TUTORIAL_PHASES.DODGING]: (dt, player, enemy, input) => this.handleDodging(dt, player, input),
          [TUTORIAL_PHASES.POST_DODGE_WAIT]: (dt, player, enemy, input) => this.handlePostDodgeWait(input),
          [TUTORIAL_PHASES.WAIT_HOLD]: (dt, player, enemy, input) => this.handleWaitHold(dt, player, enemy, input),
          [TUTORIAL_PHASES.WAIT_ATTACK]: (dt, player, enemy, input) => this.handleWaitAttack(dt, player, input),
          [TUTORIAL_PHASES.ATTACKING]: (dt, player, enemy, input) => this.handleAttacking(dt, player, enemy, input),
          [TUTORIAL_PHASES.FREE_FIGHT_FIRST_RAT]: (dt, player, enemy, input) => this.handleFreeFightFirstRat(enemy),
          [TUTORIAL_PHASES.CHAIN_SPAWNS]: (dt, player, enemy, input) => this.handleChainSpawns(dt),
          [TUTORIAL_PHASES.COMPLETE_DELAY]: (dt, player, enemy, input) => this.handleCompleteDelay(dt),
          [TUTORIAL_PHASES.WAITING_FOR_INPUT]: (dt, player, enemy, input) => this.handleWaitingForInput(dt)
        };
      }

      update(realDt) {
        if (!this.active) return;
        this.phaseTime += realDt;
        this.fingerAnimTime += realDt;
        const { player, enemy, input } = this.game;

        const handler = this.getPhaseHandlers()[this.phase];
        if (handler) {
          handler(realDt, player, enemy, input);
        }
      }

      handleIntro(enemy, input) {
        this.tutorialTimeScale = 1;
        input.pendingSwipe = null;
        if (enemy.state === "charge" && enemy.chargeDuration > 1e-7 &&
          enemy.chargeElapsed / enemy.chargeDuration >= this.dodgeSlowMoTrigger) {
          this.setPhase(TUTORIAL_PHASES.WAIT_DODGE);
          this.tutorialTimeScale = 1;
        }
      }

      handleWaitDodge(realDt, player, input) {
        if (this.tutorialTimeScale > this.crawlScale) {
          this.tutorialTimeScale = Math.max(this.crawlScale, this.tutorialTimeScale - realDt * this.slowDropRate);
        } else if (this.phaseTime > this.crawlDuration) {
          this.tutorialTimeScale = 0;
        }
        this.textAlpha = Math.min(1, this.phaseTime * 3);
        if (input.pendingSwipe) {
          const swipe = input.pendingSwipe;
          input.pendingSwipe = null;
          player.startMove("dodge", swipe.direction);
          this.tutorialTimeScale = 1;
          this.setPhase(TUTORIAL_PHASES.DODGING);
        }
      }

      handleDodging(realDt, player, input) {
        this.tutorialTimeScale = 1;
        input.pendingSwipe = null;
        this.textAlpha = Math.max(0, this.textAlpha - realDt * 5);
        if (!player.action) {
          this.setPhase(TUTORIAL_PHASES.POST_DODGE_WAIT);
        }
      }

      handlePostDodgeWait(input) {
        this.tutorialTimeScale = 1;
        input.pendingSwipe = null;
        if (this.phaseTime >= 0.2) {
          this.setPhase(TUTORIAL_PHASES.WAIT_HOLD);
          this.tutorialTimeScale = 1;
        }
      }

      handleWaitHold(realDt, player, enemy, input) {
        if (this.tutorialTimeScale > this.crawlScale) {
          this.tutorialTimeScale = Math.max(this.crawlScale, this.tutorialTimeScale - realDt * this.slowDropRate);
        } else if (this.phaseTime > this.crawlDuration) {
          this.tutorialTimeScale = 0;
        }
        this.textAlpha = Math.min(1, this.phaseTime * 3);
        input.pendingSwipe = null;
        const nowSec = performance.now() * 0.001;
        const chargeProgress = input.getChargeProgress(nowSec);
        if (chargeProgress >= 1) {
          const targetEnemy = this.game.getClosestAliveEnemy(player) || enemy;
          const dir = Vec2.sub({ x: targetEnemy.x, y: targetEnemy.y }, { x: player.x, y: player.y });
          this.attackDir = Vec2.length(dir) > 1e-5 ? Vec2.normalize(dir) : { x: 0, y: -1 };
          this.setPhase(TUTORIAL_PHASES.WAIT_ATTACK);
        }
      }

      handleWaitAttack(realDt, player, input) {
        this.tutorialTimeScale = 0;
        this.textAlpha = Math.min(1, this.phaseTime * 3);
        if (input.pendingSwipe) {
          const swipe = input.pendingSwipe;
          input.pendingSwipe = null;
          player.startMove("charged", swipe.direction);
          this.tutorialTimeScale = 1;
          this.setPhase(TUTORIAL_PHASES.ATTACKING);
        }
      }

      handleAttacking(realDt, player, enemy, input) {
        this.tutorialTimeScale = 1;
        input.pendingSwipe = null;
        this.textAlpha = Math.max(0, this.textAlpha - realDt * 3);
        if (!enemy.alive) {
          this.chainSpawnRemaining = TUTORIAL_CFG.chainSpawnCount;
          this.chainSpawnTimer = 0;
          this.setPhase(TUTORIAL_PHASES.CHAIN_SPAWNS);
          return;
        }
        if (!player.action && this.phaseTime > TUTORIAL_CFG.freeFightDelay) {
          this.setPhase(TUTORIAL_PHASES.FREE_FIGHT_FIRST_RAT);
        }
      }

      handleFreeFightFirstRat(enemy) {
        this.tutorialTimeScale = 1;
        this.textAlpha = 0;
        if (!enemy.alive) {
          this.chainSpawnRemaining = TUTORIAL_CFG.chainSpawnCount;
          this.chainSpawnTimer = 0;
          this.setPhase(TUTORIAL_PHASES.CHAIN_SPAWNS);
        }
      }

      handleChainSpawns(realDt) {
        this.tutorialTimeScale = 1;
        this.textAlpha = 0;
        if (this.chainSpawnRemaining > 0) {
          this.chainSpawnTimer = Math.max(0, this.chainSpawnTimer - realDt);
          if (this.chainSpawnTimer <= 0) {
            this.spawnEnemyFromRandomHorizontalSide();
            this.chainSpawnRemaining -= 1;
            this.chainSpawnTimer = this.chainSpawnDelay;
          }
        } else {
          const allDead = this.game.enemies.length > 0 && this.game.enemies.every(e => !e.alive);
          if (allDead) {
            this.setPhase(TUTORIAL_PHASES.COMPLETE_DELAY);
          }
        }
      }

      handleCompleteDelay(realDt) {
        this.tutorialTimeScale = 1;
        this.textAlpha = 0;
        if (this.phaseTime >= 1.0) {
          this.setPhase(TUTORIAL_PHASES.WAITING_FOR_INPUT);
          this.game.input.down = false;
          this.game.input.pendingSwipe = null;
        }
      }

      handleWaitingForInput(realDt) {
        this.tutorialTimeScale = 1;
        this.textAlpha = 0;
        if (this.game.input.down || this.game.input.pendingSwipe) {
          this.game.input.down = false;
          this.game.input.pendingSwipe = null;
          
          this.game.clearLevelState();

          this.active = false;
          this.phase = TUTORIAL_PHASES.DONE;
          this.game.levelManager.start();
        }
      }

      getTimeScale() {
        return this.active ? this.tutorialTimeScale : 1;
      }

      spawnEnemyFromRandomHorizontalSide() {
        const template = this.game.enemy;
        const enemy = new RatEnemy(0, 0);
        const fromLeft = Math.random() < 0.5;
        const spawnX = fromLeft ? -template.width : GAME_WIDTH + template.width;
        
        // Ensure tutorial enemies also spawn within vertical bounds
        const halfH = ENEMY_CFG.height * 0.5;
        const spawnY = clamp(GAME_HEIGHT * (0.22 + Math.random() * 0.56), halfH, GAME_HEIGHT - halfH);

        enemy.x = spawnX;
        enemy.y = spawnY;
        enemy.prevX = spawnX;
        enemy.prevY = spawnY;
        enemy.renderX = spawnX;
        enemy.renderY = spawnY;
        enemy.vx = 0;
        enemy.vy = 0;
        enemy.knockbackVX = 0;
        enemy.knockbackVY = 0;
        enemy.alive = true;
        enemy.entering = true;
        enemy.health = enemy.maxHealth;
        enemy.state = ENEMY_STATES.STALK;
        enemy.windupTimer = 0;
        enemy.chargeTimer = 0;
        enemy.recoverTimer = 0;
        enemy.postAttackCooldownTimer = enemy.postAttackCooldownDuration;
        enemy.lastHitByActionId = null;
        enemy.hitCooldown = 0;
        enemy.hitFlashTimer = 0;
        enemy.stunTimer = 0;
        enemy.rollAngle = 0;
        enemy.prevRollAngle = 0;
        enemy.renderRollAngle = 0;
        enemy.chargeElapsed = 0;
        enemy.trail = [];
        enemy.trailSpawnTimer = 0;

        this.game.enemies.push(enemy);
      }

      draw(ctx) {
        if (!this.active) return;

        const centerX = GAME_WIDTH * 0.5;
        const textY = GAME_HEIGHT * 0.62;
        const indicatorY = textY + 50;

        if (this.phase === TUTORIAL_PHASES.WAIT_DODGE && this.textAlpha > 0) {
          this.drawDimOverlay(ctx);
          ctx.save();
          ctx.globalAlpha = this.textAlpha;
          this.drawText(ctx, "Swipe to dodge!", centerX, textY, 30);
          this.drawSwipeIndicator(ctx, centerX, indicatorY, { x: -1, y: 0 });
          ctx.restore();
        } else if (this.phase === TUTORIAL_PHASES.WAIT_HOLD && this.textAlpha > 0) {
          this.drawDimOverlay(ctx);
          ctx.save();
          ctx.globalAlpha = this.textAlpha;
          this.drawText(ctx, "Hold", centerX, textY, 30);
          this.drawHoldIndicator(ctx, centerX, indicatorY);
          ctx.restore();
        } else if (this.phase === TUTORIAL_PHASES.WAIT_ATTACK && this.textAlpha > 0) {
          this.drawDimOverlay(ctx);
          ctx.save();
          ctx.globalAlpha = this.textAlpha;
          this.drawText(ctx, "Then swipe to attack!", centerX, textY, 26);
          this.drawSwipeIndicator(ctx, centerX, indicatorY, this.attackDir);
          ctx.restore();
        }
      }

      drawDimOverlay(ctx) {
        ctx.save();
        ctx.globalAlpha = this.textAlpha * 0.3;
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, GAME_HEIGHT * 0.55, GAME_WIDTH, GAME_HEIGHT * 0.28);
        ctx.restore();
      }

      drawText(ctx, text, x, y, size) {
        ctx.font = `bold ${size}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillText(text, x + 1.5, y + 1.5);
        ctx.fillStyle = "#ffffff";
        ctx.fillText(text, x, y);
      }

      drawSwipeIndicator(ctx, x, y, dir) {
        const cycleTime = 1.0;
        const t = (this.fingerAnimTime % cycleTime) / cycleTime;
        const swipeLen = 35;
        const startX = x - dir.x * swipeLen;
        const startY = y - dir.y * swipeLen;
        const endX = x + dir.x * swipeLen;
        const endY = y + dir.y * swipeLen;

        const moveT = t < 0.6 ? easeOutCubic(t / 0.6) : 1;
        const fingerX = startX + (endX - startX) * moveT;
        const fingerY = startY + (endY - startY) * moveT;

        if (t < 0.6) {
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,0.35)";
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(fingerX, fingerY);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }

        const alpha = t < 0.6 ? 1 : Math.max(0, 1 - (t - 0.6) / 0.4);
        ctx.save();
        ctx.globalAlpha *= alpha;
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(fingerX, fingerY, 14, 0, TAU);
        ctx.fill();
        ctx.fillStyle = "#999999";
        ctx.beginPath();
        ctx.arc(fingerX, fingerY, 6, 0, TAU);
        ctx.fill();
        ctx.restore();

        const arrowAlpha = 0.4 + 0.3 * Math.sin(this.fingerAnimTime * 5);
        ctx.save();
        ctx.globalAlpha *= arrowAlpha;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2.5;
        const angle = Math.atan2(dir.y, dir.x);
        const tipX = x + dir.x * 28;
        const tipY = y + dir.y * 28;
        const baseX = x - dir.x * 12;
        const baseY = y - dir.y * 12;
        ctx.beginPath();
        ctx.moveTo(baseX, baseY);
        ctx.lineTo(tipX, tipY);
        ctx.stroke();
        const headLen = 9;
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(tipX - Math.cos(angle - 0.45) * headLen, tipY - Math.sin(angle - 0.45) * headLen);
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(tipX - Math.cos(angle + 0.45) * headLen, tipY - Math.sin(angle + 0.45) * headLen);
        ctx.stroke();
        ctx.restore();
      }

      drawHoldIndicator(ctx, x, y) {
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(x, y, 14, 0, TAU);
        ctx.fill();
        ctx.fillStyle = "#999999";
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, TAU);
        ctx.fill();

        const pulseT = (this.fingerAnimTime % 0.9) / 0.9;
        for (let i = 0; i < 2; i++) {
          const ringT = (pulseT + i * 0.5) % 1;
          const ringAlpha = (1 - ringT) * 0.45;
          const ringRadius = 14 + ringT * 22;
          ctx.save();
          ctx.globalAlpha *= ringAlpha;
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x, y, ringRadius, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    class Renderer {
      constructor(game, ctx, screen, view) {
        this.game = game;
        this.ctx = ctx;
        this.screen = screen;
        this.view = view;
      }

      renderLevelComplete(titleText, showTapPrompt) {
        const textY = GAME_HEIGHT * 0.45;
        const centerX = GAME_WIDTH * 0.5;
        this.ctx.save();
        this.ctx.fillStyle = "rgba(0,0,0,0.5)";
        this.ctx.fillRect(-GAME_WIDTH, -GAME_HEIGHT, GAME_WIDTH * 3, GAME_HEIGHT * 3);
        this.ctx.font = "bold 36px Arial";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillStyle = "rgba(0,0,0,0.5)";
        this.ctx.fillText(titleText, centerX + 2, textY + 2);
        this.ctx.fillStyle = "#ffffff";
        this.ctx.fillText(titleText, centerX, textY);
        if (showTapPrompt) {
          const blink = Math.sin(performance.now() * 0.005) > 0;
          if (blink) {
            this.ctx.font = "bold 24px Arial";
            this.ctx.fillStyle = "#ffffff";
            this.ctx.fillText("Tap to continue", centerX, textY + 60);
          }
        }
        this.ctx.restore();
      }

      renderBackdrop() {
        this.ctx.clearRect(0, 0, this.screen.width, this.screen.height);
        this.ctx.fillStyle = "#4a4a4a";
        this.ctx.fillRect(0, 0, this.screen.width, this.screen.height);
      }

      renderPlayfield() {
        if (this.game.bgPattern) {
          this.ctx.fillStyle = this.game.bgPattern;
        } else {
          this.ctx.fillStyle = "#7cb342";
        }
        this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      }

      renderGroundSplotches() {
        for (let i = 0; i < this.game.groundSplotches.length; i++) {
          const s = this.game.groundSplotches[i];
          this.ctx.save();
          this.ctx.globalAlpha = s.alpha;
          this.ctx.fillStyle = `rgb(${s.r},${s.g},${s.b})`;
          this.ctx.beginPath();
          this.ctx.arc(s.x, s.y, s.radius, 0, TAU);
          this.ctx.fill();
          this.ctx.restore();
        }
      }

      renderWebs() {
        for (let i = 0; i < this.game.webs.length; i++) {
          this.game.webs[i].draw(this.ctx);
        }
      }

      renderEntities(nowSeconds) {
        for (let i = 0; i < this.game.enemies.length; i++) {
          this.game.enemies[i].draw(this.ctx, nowSeconds);
        }
        this.game.player.draw(this.ctx);
        for (let i = 0; i < this.game.projectiles.length; i++) {
          this.game.projectiles[i].draw(this.ctx);
        }
      }

      renderParticles() {
        this.game.particles.draw(this.ctx);
        this.game.rainbowParticles.draw(this.ctx);
      }

      renderFlashRings() {
        for (let i = 0; i < this.game.flashRings.length; i++) {
          const ring = this.game.flashRings[i];
          const t = ring.age / ring.life;
          const radius = ring.maxRadius * easeOutCubic(t);
          const alpha = 1 - t;

          this.ctx.save();
          this.ctx.globalAlpha = alpha;

          if (ring.type === "shockwave") {
            this.ctx.strokeStyle = "#ffffff";
            this.ctx.lineWidth = Math.max(0.5, 4 * (1 - t));
            this.ctx.beginPath();
            this.ctx.arc(ring.x, ring.y, radius, 0, TAU);
            this.ctx.stroke();
          } else if (ring.type === "deathFlash") {
            this.ctx.fillStyle = "#ffffff";
            this.ctx.beginPath();
            this.ctx.arc(ring.x, ring.y, radius, 0, TAU);
            this.ctx.fill();
          }

          this.ctx.restore();
        }
      }

      renderTutorial() {
        if (this.game.tutorial) {
          this.game.tutorial.draw(this.ctx);
        }
      }

      renderHealthBar() {
        const hbWidth = UI_CFG.healthBarWidth;
        const hbHeight = UI_CFG.healthBarHeight;
        const hbX = (GAME_WIDTH - hbWidth) * 0.5;
        const hbY = GAME_HEIGHT - UI_CFG.healthBarBottomMargin;
        const hpFrac = this.game.player.health / this.game.player.maxHealth;
        const displayHpFrac = this.game.player.displayHealth / this.game.player.maxHealth;
        this.ctx.save();
        this.ctx.globalAlpha = 0.35;
        this.ctx.fillStyle = "#000000";
        this.ctx.fillRect(hbX - 1, hbY - 1, hbWidth + 2, hbHeight + 2);
        this.ctx.restore();
        
        this.ctx.save();
        this.ctx.globalAlpha = 1;
        this.ctx.fillStyle = "#ffffff";
        this.ctx.fillRect(hbX, hbY, hbWidth * displayHpFrac, hbHeight);
        this.ctx.restore();

        this.ctx.save();
        this.ctx.globalAlpha = 0.25;
        this.ctx.fillStyle = "#440000";
        this.ctx.fillRect(hbX, hbY, hbWidth, hbHeight);
        this.ctx.restore();
        
        if (hpFrac > 0) {
          this.ctx.fillStyle = "#cc2222";
          this.ctx.fillRect(hbX, hbY, hbWidth * hpFrac, hbHeight);
        }
      }

      render() {
        this.renderBackdrop();

        this.ctx.save();
        this.ctx.translate(this.view.offsetX, this.view.offsetY);
        this.ctx.scale(this.view.scale, this.view.scale);
        this.ctx.translate(this.game.shakeOffsetX, this.game.shakeOffsetY);

        this.renderPlayfield();
        this.renderGroundSplotches();
        this.renderWebs();
        const nowSeconds = performance.now() * 0.001;
        this.renderEntities(nowSeconds);
        this.renderParticles();
        this.renderFlashRings();
        this.renderTutorial();
        
        if (this.game.levelManager.active && (this.game.levelManager.state === "completeDelay" || this.game.levelManager.state === "waitingForInput")) {
          this.renderLevelComplete(`Level ${this.game.levelManager.currentLevel} Complete!`, this.game.levelManager.state === "waitingForInput");
        } else if (this.game.tutorial && this.game.tutorial.active && (this.game.tutorial.phase === TUTORIAL_PHASES.COMPLETE_DELAY || this.game.tutorial.phase === TUTORIAL_PHASES.WAITING_FOR_INPUT)) {
          this.renderLevelComplete("Tutorial Complete!", this.game.tutorial.phase === TUTORIAL_PHASES.WAITING_FOR_INPUT);
        }
        
        this.renderHealthBar();
        this.ctx.restore();
      }
    }

    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.view = {
          scale: 1,
          offsetX: 0,
          offsetY: 0
        };
        this.screen = {
          width: window.innerWidth,
          height: window.innerHeight
        };

        this.bgImage = new Image();
        this.bgPattern = null;
        this.setBackground(LEVEL_BACKGROUNDS.GRASS);

        this.input = new InputSystem((event) => this.eventToWorld(event));
        this.input.bind(canvas);
        this.player = new Player();
        this.enemy = new RatEnemy(GAME_WIDTH * 0.5, 180);
        this.enemies = [this.enemy];
        this.projectiles = [];
        this.levelManager = new LevelManager(this);
        this.enemy.state = ENEMY_STATES.CHARGE;
        this.enemy.chargeDirection = { x: 0, y: 1 };
        this.enemy.chargeTimer = this.enemy.chargeDuration;
        this.enemy.chargeElapsed = 0;
        this.enemy.baseChargeSpinAmount = ENEMY_CFG.chargeSpinAmount;
        this.enemy.health = 1;
        this.enemy.displayHealth = 1;

        this.lastTimestamp = 0;
        this.accumulator = 0;
        this.fixedStep = 1 / 120;
        this.maxFrame = 0.05;

        this.shakeTimer = 0;
        this.shakeDuration = 0;
        this.shakeIntensity = 0;
        this.shakeOffsetX = 0;
        this.shakeOffsetY = 0;

        this.hitstopTimer = 0;

        this.timeScale = 1;
        this.timeSlowTimer = 0;
        this.timeSlowDuration = 0;
        this.timeSlowMinScale = 0.15;

        this.particles = new ParticleSystem();
        this.rainbowParticles = new RainbowDeathParticleSystem();
        this.flashRings = [];
        this.groundSplotches = [];
        this.webs = [];

        this.tutorial = new Tutorial(this);

        window.addEventListener("resize", () => this.resize());
        this.resize();
      }

      setBackground(svgData) {
        this.bgImage.onload = () => {
          this.bgPattern = this.ctx.createPattern(this.bgImage, "repeat");
        };
        this.bgImage.src = svgData;
      }

      clearLevelState() {
        this.groundSplotches = [];
        this.webs = [];
        this.particles.particles = [];
        this.rainbowParticles.particles = [];
        this.flashRings = [];
        this.projectiles = [];
        this.enemies = [];
        this.player.resetPosition();
      }

      spawnEnemy(type) {
        let enemy;
        const fromLeft = Math.random() < 0.5;
        const spawnX = fromLeft ? -50 : GAME_WIDTH + 50;
        
        // Spawn them on screen vertically
        const halfH = ENEMY_CFG.height * 0.5;
        const spawnY = clamp(GAME_HEIGHT * (0.1 + Math.random() * 0.8), halfH, GAME_HEIGHT - halfH);
        
        if (type === "rat") enemy = new RatEnemy(spawnX, spawnY);
        else if (type === "bat") enemy = new BatEnemy(spawnX, spawnY);
        else if (type === "snake") enemy = new SnakeEnemy(spawnX, spawnY);
        else if (type === "spider") enemy = new SpiderEnemy(spawnX, spawnY);
        else if (type === "boar") enemy = new BoarEnemy(spawnX, spawnY);
        else enemy = new RatEnemy(spawnX, spawnY);
        
        enemy.entering = true;
        this.enemies.push(enemy);
      }

      resize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
        this.canvas.width = Math.floor(this.screen.width * dpr);
        this.canvas.height = Math.floor(this.screen.height * dpr);
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const scale = Math.min(this.screen.width / GAME_WIDTH, this.screen.height / GAME_HEIGHT);
        this.view.scale = scale;
        this.view.offsetX = (this.screen.width - GAME_WIDTH * scale) * 0.5;
        this.view.offsetY = (this.screen.height - GAME_HEIGHT * scale) * 0.5;
      }

      eventToWorld(event) {
        const rect = this.canvas.getBoundingClientRect();
        const sx = event.clientX - rect.left;
        const sy = event.clientY - rect.top;
        return {
          x: (sx - this.view.offsetX) / this.view.scale,
          y: (sy - this.view.offsetY) / this.view.scale
        };
      }

      triggerShake(intensity, duration) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
        this.shakeTimer = duration;
      }

      triggerHitstop(duration) {
        this.hitstopTimer = Math.max(this.hitstopTimer, duration);
      }

      triggerTimeSlow(duration, minScale) {
        this.timeSlowDuration = duration;
        this.timeSlowTimer = duration;
        this.timeSlowMinScale = minScale;
      }

      getClosestAliveEnemy(fromEntity) {
        let bestEnemy = null;
        let bestDistSq = Infinity;
        for (let i = 0; i < this.enemies.length; i++) {
          const enemy = this.enemies[i];
          if (!enemy.alive) {
            continue;
          }
          const distSq = MathUtils.distanceSq(enemy.x, enemy.y, fromEntity.x, fromEntity.y);
          if (distSq < bestDistSq) {
            bestDistSq = distSq;
            bestEnemy = enemy;
          }
        }
        return bestEnemy;
      }

      update(dt) {
        this.particles.update(dt);
        this.rainbowParticles.update(dt, this.player, this.groundSplotches);

        for (let i = this.flashRings.length - 1; i >= 0; i--) {
          this.flashRings[i].age += dt;
          if (this.flashRings[i].age >= this.flashRings[i].life) {
            MathUtils.swapAndPop(this.flashRings, i);
          }
        }

        if (this.shakeTimer > 0) {
          this.shakeTimer = Math.max(0, this.shakeTimer - dt);
          const t = this.shakeTimer / this.shakeDuration;
          const mag = this.shakeIntensity * t;
          this.shakeOffsetX = (Math.random() * 2 - 1) * mag;
          this.shakeOffsetY = (Math.random() * 2 - 1) * mag;
        } else {
          this.shakeOffsetX = 0;
          this.shakeOffsetY = 0;
        }

        if (this.hitstopTimer > 0) {
          this.hitstopTimer = Math.max(0, this.hitstopTimer - dt);
          return;
        }

        const nowSeconds = performance.now() * 0.001;
        for (let i = this.webs.length - 1; i >= 0; i--) {
          this.webs[i].update(dt);
          if (this.webs[i].expired) {
            MathUtils.swapAndPop(this.webs, i);
          }
        }

        this.player.update(dt, this.input, nowSeconds, this);
        for (let i = 0; i < this.enemies.length; i++) {
          this.enemies[i].update(dt, this.player, this);
        }
        for (let i = 0; i < this.enemies.length; i++) {
          this.enemies[i].onPlayerContact(this.player, this);
          this.enemies[i].checkDamageToPlayer(this.player, this);
        }
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
          this.projectiles[i].update(dt, this);
          if (!this.projectiles[i].alive) {
            MathUtils.swapAndPop(this.projectiles, i);
          }
        }
      }

      render() {
        if (!this.renderer) {
          this.renderer = new Renderer(this, this.ctx, this.screen, this.view);
        }
        this.renderer.render();
      }

      frame = (timestamp) => {
        if (!this.lastTimestamp) {
          this.lastTimestamp = timestamp;
        }

        let frameDt = (timestamp - this.lastTimestamp) / 1000;
        this.lastTimestamp = timestamp;
        frameDt = clamp(frameDt, 0, this.maxFrame);

        if (this.tutorial && this.tutorial.active) {
          this.tutorial.update(frameDt);
        }

        this.levelManager.update(frameDt);

        if (this.timeSlowTimer > 0) {
          this.timeSlowTimer = Math.max(0, this.timeSlowTimer - frameDt);
          const elapsed = 1 - (this.timeSlowTimer / this.timeSlowDuration);
          this.timeScale = this.timeSlowMinScale + (1 - this.timeSlowMinScale) * (elapsed * elapsed * elapsed);
        } else {
          this.timeScale = 1;
        }

    const holdDt = this.hitstopTimer > 0 ? 0 : frameDt * this.timeScale;
    this.input.advanceHold(holdDt);

    this.accumulator += frameDt;
    while (this.accumulator >= this.fixedStep) {
      const tutScale = this.tutorial ? this.tutorial.getTimeScale() : 1;
      this.update(this.fixedStep * this.timeScale * tutScale);
      this.accumulator -= this.fixedStep;
    }

        const interpAlpha = this.fixedStep > 1e-7 ? clamp(this.accumulator / this.fixedStep, 0, 1) : 1;
        for (let i = 0; i < this.enemies.length; i++) {
          this.enemies[i].interpolate(interpAlpha);
        }

        this.render();
        requestAnimationFrame(this.frame);
      };

      start() {
        requestAnimationFrame(this.frame);
      }
    }

    const game = new Game(document.getElementById("gameCanvas"));
    game.start();

    document.getElementById("levelSelect").addEventListener("change", (e) => {
      const levelIdx = parseInt(e.target.value, 10);
      if (game.tutorial) {
        game.tutorial.active = false;
      }
      game.clearLevelState();
      game.levelManager.active = true;
      game.levelManager.currentLevel = levelIdx;
      game.levelManager.startLevel();
      e.target.blur();
    });
  </script>
</body>
</html>
