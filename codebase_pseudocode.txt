BLEAK SWORD GIZMO PROTOTYPE
COMPREHENSIVE IMPLEMENTATION PSEUDOCODE (CURRENT CODEBASE)

========================================================================
0) PURPOSE + COVERAGE
========================================================================

This document is a comprehensive pseudocode translation of the current game
runtime implemented in:

  - index.html

It is intended to serve as:
  1) architecture reference
  2) gameplay behavior spec
  3) refactor-safe baseline for future changes

This reflects the current refactored architecture:
  - grouped config constants
  - helper-method decomposition in Player and TriangleEnemy
  - layered rendering in Game


========================================================================
1) HIGH-LEVEL ARCHITECTURE
========================================================================

Single-page app with one canvas.

Main runtime units:
  - Utility/math layer:
      clamp, easeOutCubic, Vec2, hslToRgb
  - Input layer:
      InputSystem (pointer tracking + swipe charge logic)
  - Entity layer:
      Player
      TriangleEnemy
  - Effects layer:
      ParticleSystem
      RainbowDeathParticleSystem
      flashRings array in Game
      groundSplotches / player stains
  - Flow layer:
      Tutorial phase state machine
  - Orchestrator:
      Game (fixed-step update loop + rendering)

Time model:
  - frame delta from requestAnimationFrame is clamped
  - simulation uses accumulator with fixedStep = 1/120 seconds
  - all movement and timers use dt (seconds)
  - timeScale and tutorialTimeScale multiply simulation time
  - input hold duration is dt-accumulated, not frame-count based


========================================================================
2) HTML + CSS SURFACE
========================================================================

HTML:
  <canvas id="gameCanvas"></canvas>
  <script> // all runtime code in one block

CSS:
  :root color-scheme light
  * box-sizing border-box + disable text selection/touch callout
  html/body:
    margin 0
    width/height 100%
    overflow hidden
    background #6a6a6a
  #gameCanvas:
    width/height viewport
    display block
    touch-action none


========================================================================
3) GLOBAL CONSTANTS
========================================================================

3.1 Scalar Globals
  GAME_WIDTH  = 500
  GAME_HEIGHT = 720
  TAU         = 2 * PI
  EPSILON     = 1e-7

3.2 INPUT_CFG
  minSwipeDistance    = 14
  chargeStartDelay    = 0.1
  chargeFillDuration  = 0.2
  chargeGraceThreshold= 0.75

3.3 PLAYER_CFG
  width                     = 10.08
  height                    = 43.2
  maxHealth                 = 4
  iframeDuration            = 0.5
  hitFlashDuration          = 0.3
  dodgeDuration             = 0.12
  chargedDuration           = 0.2
  dodgeTravel               = 78
  chargedTravel             = 150
  dodgeSpin                 = PI * 0.8
  chargedSpin               = TAU * 2
  chargedTrailInterval      = 0.0064
  dodgeTrailInterval        = 0.016
  dodgeTrailLife            = 0.32
  chargedTrailLife          = 0.44
  dodgeTrailAlpha           = 0.2
  chargedTrailAlpha         = 0.3
  maxTrailSamples           = 48
  idleDampingRate           = 18
  shakeOnHit.intensity      = 8
  shakeOnHit.duration       = 0.2
  trailPositionThresholdSq  = 0.01
  trailAngleThreshold       = 0.01

3.4 ENEMY_CFG
  width                        = 33
  height                       = 30
  hitRadius                    = 18
  maxHealthQuarters            = 4
  chargeTriggerDistance        = 75
  windupDuration               = 0.57
  chargeDuration               = 0.256
  recoverDuration              = 0.3
  postAttackCooldownDuration   = 0.75
  stalkSpeed                   = 36
  chargeSpeed                  = 560
  stunDuration                 = 0.32
  chargeSpinAmount             = TAU * 1.4
  chargeTrailInterval          = 0.016
  chargeTrailLife              = 0.34
  chargeTrailAlpha             = 0.24
  maxTrailSamples              = 36
  recoverDampingRate           = 10
  knockbackDampingRate         = 7
  combatReachPlayerFactor      = 0.38
  hitFlashDuration             = 0.09
  hitCooldownDuration          = 0.16
  knockbackImpulse             = 520
  defaultChargeDirection       = {x:0, y:1}

3.5 FX_CFG
  hitParticleCount             = 12
  hitParticleSpread            = PI * 0.8
  hitParticleMinSpeed          = 180
  hitParticleMaxSpeed          = 420
  hitParticleMinLife           = 0.15
  hitParticleMaxLife           = 0.35
  hitParticleMinSize           = 3
  hitParticleMaxSize           = 7
  hitParticleColors            = ["#ffffff","#ffffaa","#ffdd66"]
  hitParticleDrag              = 5
  hitRingRadius                = 80
  hitRingLife                  = 0.25
  hitShake                     = {intensity:6, duration:0.15}
  hitstopDuration              = 0.05
  hitTimeSlow                  = {duration:0.3, minScale:0.15}
  deathShake                   = {intensity:14, duration:0.3}
  deathHitstopDuration         = 0.12
  deathTimeSlow                = {duration:0.55, minScale:0.06}
  deathRingRadius              = 120
  deathRingLife                = 0.4
  deathParticleCount           = 24
  deathParticleMinSpeed        = 100
  deathParticleMaxSpeed        = 350
  deathParticleMinLife         = 0.3
  deathParticleMaxLife         = 0.6
  deathParticleMinSize         = 4
  deathParticleMaxSize         = 10
  deathParticleColors          = ["#d62222","#ff4444","#ff8800","#ffaa22"]
  deathParticleDrag            = 3
  rainbowMinCount              = 150
  rainbowExtraCount            = 51

3.6 UI_CFG
  healthBarWidth               = 160
  healthBarHeight              = 10
  healthBarBottomMargin        = 24


========================================================================
4) UTILITY FUNCTIONS + TYPES
========================================================================

FUNCTION clamp(value, minValue, maxValue):
  return max(minValue, min(value, maxValue))

FUNCTION easeOutCubic(t):
  return 1 - (1 - t)^3

CLASS Vec2:
  static add(a, b):
    return {x:a.x+b.x, y:a.y+b.y}

  static sub(a, b):
    return {x:a.x-b.x, y:a.y-b.y}

  static mul(v, scalar):
    return {x:v.x*scalar, y:v.y*scalar}

  static length(v):
    return hypot(v.x, v.y)

  static normalize(v):
    len = Vec2.length(v)
    if len <= EPSILON: return {x:0, y:0}
    return {x:v.x/len, y:v.y/len}

FUNCTION hslToRgb(h, s, l):
  Convert HSL space to RGB integer triple:
    normalize s/l into [0,1]
    compute chroma c, intermediary x, offset m
    resolve hue sextant
    return rounded {r,g,b} in [0..255]


========================================================================
5) INPUT SYSTEM
========================================================================

CLASS InputSystem(getWorldPointer):
  Data fields:
    getWorldPointer: function(pointerEvent) -> world {x,y} or null
    activePointerId: pointer id being tracked
    down: boolean pointer active
    start/current: world coords at press and latest move
    holdGameDuration: seconds held in simulation time
    pendingSwipe: null or {direction,distance,holdDuration,fullyCharged}
    minSwipeDistance
    chargeStartDelay
    chargeFillDuration
    fullChargeThreshold = chargeStartDelay + chargeFillDuration
    chargeGraceThreshold

  METHOD bind(canvas):
    add pointerdown => onPointerDown
    add pointermove => onPointerMove
    add pointerup and pointercancel => onPointerUp

  METHOD isInPlayfield(point):
    return 0 <= x <= GAME_WIDTH AND 0 <= y <= GAME_HEIGHT

  METHOD onPointerDown(event):
    if down already true: return
    world = getWorldPointer(event)
    if world missing OR out of bounds: return
    down = true
    activePointerId = event.pointerId
    start = world
    current = world
    holdGameDuration = 0
    pendingSwipe = null

  METHOD onPointerMove(event):
    if not down: return
    if event.pointerId != activePointerId: return
    world = getWorldPointer(event)
    if world missing: return
    current = world

  METHOD onPointerUp(event):
    if not down: return
    if event.pointerId != activePointerId: return
    world = getWorldPointer(event)
    releasePos = world OR current
    holdDuration = holdGameDuration
    swipeVec = releasePos - start
    swipeDistance = length(swipeVec)
    if swipeDistance >= minSwipeDistance:
      chargeAtRelease = 0 if holdDuration < chargeStartDelay
                       else clamp((holdDuration-chargeStartDelay)/chargeFillDuration,0,1)
      pendingSwipe = {
        direction: normalize(swipeVec)
        distance: swipeDistance
        holdDuration
        fullyCharged: chargeAtRelease >= chargeGraceThreshold
      }
    down = false
    activePointerId = null

  METHOD advanceHold(dt):
    if down: holdGameDuration += dt

  METHOD consumeSwipe():
    out = pendingSwipe
    pendingSwipe = null
    return out

  METHOD getHoldDuration(nowSeconds):
    if not down: return 0
    return holdGameDuration

  METHOD getChargeProgress(nowSeconds):
    hold = getHoldDuration(nowSeconds)
    if hold < chargeStartDelay: return 0
    return clamp((hold-chargeStartDelay)/chargeFillDuration,0,1)


========================================================================
6) PLAYER ENTITY
========================================================================

CLASS Player:
  Fields:
    x,y,vx,vy
    width,height
    baseAngle,spinAngle
    action (null or action object)
    actionSerial
    trail[]
    trailSpawnTimer
    stains[]
    maxHealth,health
    iframeDuration,iframeTimer
    hitFlashTimer

  Action object schema:
    {
      id,
      type: "dodge" | "charged",
      direction:{x,y},
      duration,
      elapsed,
      travel,
      spins,
      startAngle,
      prevTravelT
    }

  METHOD startMove(type, direction):
    dir = normalize(direction)
    horizontalSign = +1 if dir.x >= 0 else -1
    isDodge = (type=="dodge")
    duration = dodgeDuration OR chargedDuration
    travel   = dodgeTravel OR chargedTravel
    spins    = dodgeSpin*sign OR chargedSpin*sign
    actionSerial += 1
    action = new object with elapsed=0, prevTravelT=0

  METHOD takeDamage(game):
    if iframeTimer > 0 OR health <= 0: return
    health = max(0, health-1)
    iframeTimer = iframeDuration
    hitFlashTimer = PLAYER_CFG.hitFlashDuration
    game.triggerShake(...)

  METHOD update(dt, input, nowSeconds):
    updateStatusTimers(dt)
    consumeQueuedSwipe(input)
    updateAction(dt)
    applyPostActionDamping(dt)
    applyMovement(dt)
    clampToPlayfield()
    ageTrail(dt)

  METHOD updateStatusTimers(dt):
    iframeTimer = max(0, iframeTimer-dt)
    hitFlashTimer = max(0, hitFlashTimer-dt)

  METHOD consumeQueuedSwipe(input):
    swipe = input.consumeSwipe()
    if swipe exists:
      moveType = "charged" if swipe.fullyCharged else "dodge"
      startMove(moveType, swipe.direction)

  METHOD updateAction(dt):
    if action is null: return

    frameStartX = x
    frameStartY = y
    frameStartAngle = spinAngle

    action.elapsed += dt
    t = clamp(action.elapsed / action.duration, 0, 1)

    if action.type == "charged":
      travelT = easeOutCubic(t)
      deltaTravel = (travelT - action.prevTravelT) * action.travel
      action.prevTravelT = travelT
      moveX = action.direction.x * deltaTravel
      moveY = action.direction.y * deltaTravel
      x += moveX
      y += moveY
      if dt > EPSILON:
        vx = moveX / dt
        vy = moveY / dt
      else:
        vx = 0
        vy = 0
    else:
      speed = action.travel / action.duration
      vx = action.direction.x * speed
      vy = action.direction.y * speed

    spinAngle = action.startAngle + action.spins * easeOutCubic(t)

    trailInterval = chargedTrailInterval OR dodgeTrailInterval based on action.type
    trailSpawnTimer += dt
    WHILE trailSpawnTimer >= trailInterval:
      sampleTimeInFrame = dt - (trailSpawnTimer - trailInterval)
      sampleT = 1 if dt <= EPSILON else clamp(sampleTimeInFrame/dt, 0, 1)
      sampleX = lerp(frameStartX, x, sampleT)
      sampleY = lerp(frameStartY, y, sampleT)
      sampleAngle = lerp(frameStartAngle, spinAngle, sampleT)
      trailSpawnTimer -= trailInterval

      prev = last trail sample if any
      if prev exists:
        dx = prev.x - sampleX
        dy = prev.y - sampleY
        da = abs(prev.angle - sampleAngle)
        if (dx*dx + dy*dy) < trailPositionThresholdSq AND da < trailAngleThreshold:
          continue

      append trail sample with action-specific life + alpha
      if trail.length > maxTrailSamples: drop oldest

    if action.elapsed >= action.duration:
      action = null
      vx = 0
      vy = 0
      spinAngle = 0

  METHOD applyPostActionDamping(dt):
    if action exists: return
    vx *= max(0, 1 - dt * idleDampingRate)
    vy *= max(0, 1 - dt * idleDampingRate)
    spinAngle = 0

  METHOD applyMovement(dt):
    if action missing OR action.type != "charged":
      x += vx * dt
      y += vy * dt

  METHOD clampToPlayfield():
    halfW = width*0.5
    halfH = height*0.5
    x = clamp(x, halfW, GAME_WIDTH-halfW)
    y = clamp(y, halfH, GAME_HEIGHT-halfH)

  METHOD ageTrail(dt):
    iterate trail backwards:
      sample.age += dt
      remove if sample.age >= sample.life

  METHOD draw(ctx, chargeProgress, chargeVisible):
    draw trail rectangles (fading)
    if charging action active:
      draw white ring around player
    draw two ground shadows
    if hitFlashTimer active and sine blink condition true:
      return (skip player body for blink effect)
    draw black outline box
    draw white body rect
    draw stains clipped inside body
    if chargeVisible AND no action:
      draw circular charge arc from -PI/2 to -PI/2 + TAU*chargeProgress


========================================================================
7) ENEMY ENTITY (TriangleEnemy, rat emoji visual)
========================================================================

CLASS TriangleEnemy(x, y):
  Key fields:
    sim: x,y,vx,vy,knockbackVX,knockbackVY
    interpolation: prevX,prevY,prevRollAngle -> renderX,renderY,renderRollAngle
    core: width,height,hitRadius,alive,healthQuarters,maxHealthQuarters
    state machine:
      state in {"stalk","windup","charge","recover"}
      timers: windupTimer,chargeTimer,recoverTimer,postAttackCooldownTimer
      tunables copied from ENEMY_CFG
    status timers:
      waddleTime, hitCooldown, hitFlashTimer, stunTimer
    charge data:
      chargeDirection, chargeElapsed, chargeSpinAmount
    trail[] + trailSpawnTimer
    entering boolean (spawn transition from offscreen)
    lastHitByActionId

  METHOD update(dt, player):
    if not alive: return
    cachePreviousTransform()
    updateTimers(dt)
    ageTrail(dt)
    toPlayer = playerPos - thisPos
    playerDistance = length(toPlayer)
    toPlayerDir = normalize(toPlayer) or {0,0}
    updateState(dt, playerDistance, toPlayerDir)
    applyKnockbackDamping(dt)
    integratePosition(dt)
    clampToPlayfield()

  METHOD cachePreviousTransform():
    prevX = x
    prevY = y
    prevRollAngle = rollAngle

  METHOD updateTimers(dt):
    waddleTime += dt
    hitCooldown = max(0, hitCooldown-dt)
    hitFlashTimer = max(0, hitFlashTimer-dt)
    stunTimer = max(0, stunTimer-dt)
    postAttackCooldownTimer = max(0, postAttackCooldownTimer-dt)

  METHOD ageTrail(dt):
    remove expired trail samples

  METHOD updateState(dt, playerDistance, toPlayerDir):
    if stunTimer > 0:
      vx=0; vy=0; rollAngle=0
      return
    if state=="stalk": updateStalkState(...)
    else if state=="windup": updateWindupState(dt)
    else if state=="charge": updateChargeState(dt)
    else if state=="recover": updateRecoverState(dt)

  METHOD updateStalkState(playerDistance, toPlayerDir):
    vx = toPlayerDir.x * stalkSpeed
    vy = toPlayerDir.y * stalkSpeed
    rollAngle = 0
    if playerDistance <= chargeTriggerDistance AND postAttackCooldownTimer <= 0:
      state = "windup"
      windupTimer = windupDuration
      chargeDirection = toPlayerDir
      if length(chargeDirection) <= EPSILON: chargeDirection = defaultChargeDirection
      vx=0; vy=0

  METHOD updateWindupState(dt):
    vx=0; vy=0; rollAngle=0
    windupTimer -= dt
    if windupTimer <= 0:
      state = "charge"
      chargeTimer = chargeDuration
      chargeElapsed = 0
      spinSign = +1 if chargeDirection.x >= 0 else -1
      chargeSpinAmount = ENEMY_CFG.chargeSpinAmount * spinSign

  METHOD updateChargeState(dt):
    vx = chargeDirection.x * chargeSpeed
    vy = chargeDirection.y * chargeSpeed
    chargeElapsed += dt
    chargeT = clamp(chargeElapsed/chargeDuration,0,1)
    rollAngle = chargeSpinAmount * easeOutCubic(chargeT)
    spawnChargeTrail(dt)
    chargeTimer -= dt
    if chargeTimer <= 0:
      state = "recover"
      recoverTimer = recoverDuration
      postAttackCooldownTimer = postAttackCooldownDuration

  METHOD spawnChargeTrail(dt):
    trailSpawnTimer += dt
    while trailSpawnTimer >= chargeTrailInterval:
      trailSpawnTimer -= chargeTrailInterval
      push trail sample at current x,y,rollAngle
      if trail.length > maxTrailSamples: shift oldest

  METHOD updateRecoverState(dt):
    damp = max(0, 1 - dt*recoverDampingRate)
    vx*=damp; vy*=damp; rollAngle=0
    recoverTimer -= dt
    if recoverTimer <= 0: state="stalk"

  METHOD applyKnockbackDamping(dt):
    damp = max(0, 1 - dt*knockbackDampingRate)
    knockbackVX*=damp
    knockbackVY*=damp

  METHOD integratePosition(dt):
    x += (vx + knockbackVX) * dt
    y += (vy + knockbackVY) * dt

  METHOD clampToPlayfield():
    halfW = width*0.5
    halfH = height*0.5
    if entering and x now inside [halfW, GAME_WIDTH-halfW]:
      entering = false
    if NOT entering:
      x = clamp(x, halfW, GAME_WIDTH-halfW)
    y = clamp(y, halfH, GAME_HEIGHT-halfH)

  METHOD isOverlappingPlayer(player):
    combatReach = max(player.width,player.height)*combatReachPlayerFactor + hitRadius
    return distSq(player,enemy) <= combatReach^2

  METHOD onPlayerContact(player, game):
    if not canReceiveChargedHit(player): return
    away = getAwayFromHitDirection(player)
    applyChargedHit(player, away)
    hitX = midpoint x
    hitY = midpoint y
    spawnChargedHitEffects(game, hitX, hitY, away)
    if healthQuarters <= 0: handleDeath(game)

  METHOD canReceiveChargedHit(player):
    guard false if:
      !alive
      !player.action
      !overlap
      action is dodge
      action is not charged
      hitCooldown > 0
      lastHitByActionId == player.action.id
    else true

  METHOD getAwayFromHitDirection(player):
    away = normalize(enemyPos - playerPos)
    if away near zero: return player.action.direction OR defaultChargeDirection
    return away

  METHOD applyChargedHit(player, away):
    healthQuarters = max(0, healthQuarters-1)
    lastHitByActionId = player.action.id
    hitFlashTimer = hitFlashDuration
    hitCooldown = hitCooldownDuration
    stunTimer = stunDuration
    state = "recover"
    recoverTimer = recoverDuration
    knockbackVX += away.x * knockbackImpulse
    knockbackVY += away.y * knockbackImpulse

  METHOD spawnChargedHitEffects(game, hitX, hitY, away):
    emit hit particles using FX_CFG hit ranges
    push shockwave ring
    trigger hit shake + hitstop + time slow

  METHOD handleDeath(game):
    alive = false
    trigger death shake + hitstop + time slow
    push death flash ring
    emit death particles
    emit rainbow particles count = rainbowMinCount + random[0..rainbowExtraCount-1]

  METHOD checkDamageToPlayer(player, game):
    if not alive: return
    if state != "charge": return
    if player iframe active or hp <=0: return
    if player is dodging action: return
    if not overlapping: return
    player.takeDamage(game)

  METHOD interpolate(alpha):
    renderX = lerp(prevX, x, alpha)
    renderY = lerp(prevY, y, alpha)
    renderRollAngle = lerp(prevRollAngle, rollAngle, alpha)

  METHOD draw(ctx, nowSeconds):
    if !alive: return
    draw trail emoji ghosts
    draw shadows
    waddle = sin(waddleTime*12)*0.12 in stalk/recover else 0
    apply hit/windup alpha flicker
    draw rat emoji rotated by waddle + renderRollAngle


========================================================================
8) PARTICLE SYSTEMS
========================================================================

CLASS ParticleSystem:
  particles[] entries:
    x,y,vx,vy,life,maxLife,size,color,drag

  emit(x, y, count, config):
    repeat count:
      angle = baseAngle + random spread offset
      speed/life/size random in config min/max
      push new particle

  update(dt):
    iterate reverse:
      if drag>0: damp velocities by (1 - dt*drag)
      integrate x/y
      life -= dt
      remove when life <= 0

  draw(ctx):
    for each:
      t = life/maxLife
      sizeNow = size * (0.3 + 0.7*t)
      alpha = t^2
      rotate by velocity angle
      draw stretched rect


CLASS RainbowDeathParticleSystem:
  particles[] entries:
    x,y,z,vx,vy,vz,r,g,b,size,gravity,bounciness,drag

  emit(x,y,count):
    repeat count:
      angle random [0..TAU)
      speed random up to 520
      hue random [0..360)
      color = hslToRgb(hue,100,50)
      push particle with random vz,size,bounciness and fixed gravity/drag

  update(dt, player, groundSplotches):
    for each particle reverse:
      vz -= gravity*dt
      damp vx/vy by drag
      integrate x,y,z
      reflect x/y at world bounds with bounciness

      if z <= 0 AND vz < 0:
        compute player AABB
        stainRadius = size*(1 + random)
        directHit = point inside AABB
        splashHit = distance(point to nearest AABB point) <= stainRadius
        if directHit OR splashHit:
          add stain to player.stains with local coords + alpha random
        if NOT directHit:
          add ground splotch with radius random scale + alpha random
        remove particle

  draw(ctx):
    for each:
      visualY = y - z*0.7
      scale = 1 + z*0.002
      draw colored circle with global alpha 0.425


========================================================================
9) TUTORIAL SYSTEM
========================================================================

CLASS Tutorial(game):
  fields:
    game
    phase
    phaseTime
    dodgeSlowMoTrigger = 0.45
    tutorialTimeScale
    textAlpha
    fingerAnimTime
    active
    attackDir
    crawlScale = 0.03
    crawlDuration = 2.8
    slowDropRate = 12
    chainSpawnRemaining
    chainSpawnDelay = 0.2
    chainSpawnTimer

  METHOD setPhase(newPhase):
    phase = newPhase
    phaseTime = 0
    fingerAnimTime = 0
    textAlpha = 0

  METHOD update(realDt):
    if !active: return
    phaseTime += realDt
    fingerAnimTime += realDt
    references: player, enemy, input

    switch phase:
      "intro":
        tutorialTimeScale = 1
        input.pendingSwipe = null
        if enemy in charge and charge progress >= dodgeSlowMoTrigger:
          setPhase("waitDodge")
          tutorialTimeScale = 1

      "waitDodge":
        reduce tutorialTimeScale toward crawl and eventually 0
        textAlpha fades in
        if swipe queued:
          consume pending swipe
          force player dodge
          tutorialTimeScale = 1
          setPhase("dodging")

      "dodging":
        tutorialTimeScale = 1
        clear pending swipe
        fade text out quickly
        when player.action ends -> setPhase("postDodgeWait")

      "postDodgeWait":
        tutorialTimeScale = 1
        clear pending swipe
        after 0.2s -> setPhase("waitHold")

      "waitHold":
        reduce time scale to crawl/0, fade text in
        clear pending swipe
        if input chargeProgress >= 1:
          targetEnemy = closest alive or base enemy
          attackDir = normalized(targetEnemy - player) fallback up
          setPhase("waitAttack")

      "waitAttack":
        tutorialTimeScale = 0
        fade text in
        if swipe queued:
          consume swipe
          force player charged move
          tutorialTimeScale = 1
          setPhase("attacking")

      "attacking":
        tutorialTimeScale = 1
        clear pending swipe
        fade text out
        if base enemy dies:
          chainSpawnRemaining = 3
          chainSpawnTimer = 0
          setPhase("chainSpawns")
        else if player action finished and phaseTime > 0.5:
          active = false
          phase = "done"
          tutorialTimeScale = 1

      "chainSpawns":
        tutorialTimeScale = 1
        textAlpha = 0
        if chainSpawnRemaining > 0:
          chainSpawnTimer = max(0, chainSpawnTimer-realDt)
          if chainSpawnTimer <= 0:
            spawnEnemyFromRandomHorizontalSide()
            chainSpawnRemaining -= 1
            chainSpawnTimer = chainSpawnDelay
        else:
          if all enemies are dead:
            active = false
            phase = "done"

  METHOD getTimeScale():
    return tutorialTimeScale if active else 1

  METHOD spawnEnemyFromRandomHorizontalSide():
    template = game.enemy
    enemy = new TriangleEnemy(0,0)
    fromLeft = random < 0.5
    spawnX = -template.width OR GAME_WIDTH + template.width
    spawnY = GAME_HEIGHT * (0.22 + random*0.56)
    set enemy runtime fields for a fresh entering spawn
    enemy.entering = true
    enemy.healthQuarters = 3
    enemy.postAttackCooldownTimer = postAttackCooldownDuration
    clear trail and action-related transient fields
    push enemy into game.enemies

  METHOD draw(ctx):
    if !active: return
    draw contextual overlays only for:
      waitDodge: "Swipe to dodge!" + swipe indicator left
      waitHold : "Hold" + pulsing hold indicator
      waitAttack: "Then swipe to attack!" + indicator in attackDir

  Auxiliary draw methods:
    drawDimOverlay
    drawText
    drawSwipeIndicator
    drawHoldIndicator


========================================================================
10) GAME ORCHESTRATOR
========================================================================

CLASS Game(canvas):
  Core fields:
    canvas, ctx
    view {scale, offsetX, offsetY}
    screen {width, height}
    input
    player
    enemy (base enemy)
    enemies[]
    timing:
      lastTimestamp
      accumulator
      fixedStep = 1/120
      maxFrame = 0.05
    shake:
      shakeTimer, shakeDuration, shakeIntensity, shakeOffsetX, shakeOffsetY
    hitstopTimer
    time-slow:
      timeScale
      timeSlowTimer, timeSlowDuration, timeSlowMinScale
    particles
    rainbowParticles
    flashRings[]
    groundSplotches[]
    tutorial

  constructor(canvas):
    initialize context/view/screen
    create InputSystem(bound eventToWorld)
    bind input listeners
    create player
    create base enemy centered high on screen
    enemies = [base enemy]
    seed base enemy into charge state for tutorial opening:
      state="charge"
      chargeDirection={0,1}
      chargeTimer=chargeDuration
      chargeElapsed=0
      chargeSpinAmount=ENEMY_CFG.chargeSpinAmount
      healthQuarters=1
    initialize timing/effect fields
    create particle systems and tutorial
    subscribe window resize => resize()
    call resize()

  METHOD resize():
    dpr = max(1, devicePixelRatio || 1)
    screen width/height from window
    canvas pixel size = floor(screen*dpr)
    ctx.setTransform(dpr,0,0,dpr,0,0)
    scale = min(screenW/GAME_WIDTH, screenH/GAME_HEIGHT)
    view.scale = scale
    view offsets center logical playfield

  METHOD eventToWorld(event):
    rect = canvas bounding rect
    sx/sy = event client position relative to rect
    return {
      x: (sx - view.offsetX)/view.scale
      y: (sy - view.offsetY)/view.scale
    }

  METHOD triggerShake(intensity, duration):
    set shakeIntensity
    set shakeDuration
    set shakeTimer = duration

  METHOD triggerHitstop(duration):
    hitstopTimer = max(hitstopTimer, duration)

  METHOD triggerTimeSlow(duration, minScale):
    timeSlowDuration = duration
    timeSlowTimer = duration
    timeSlowMinScale = minScale

  METHOD getClosestAliveEnemy(fromEntity):
    linear scan of enemies[]
    skip dead
    return enemy with min squared distance

  METHOD update(dt):
    particles.update(dt)
    rainbowParticles.update(dt, player, groundSplotches)

    age flashRings and remove expired

    if shakeTimer > 0:
      shakeTimer = max(0, shakeTimer-dt)
      t = shakeTimer/shakeDuration
      mag = shakeIntensity * t
      shakeOffsetX = random(-1..1) * mag
      shakeOffsetY = random(-1..1) * mag
    else:
      shake offsets = 0

    if hitstopTimer > 0:
      hitstopTimer = max(0, hitstopTimer-dt)
      return

    nowSeconds = performance.now() * 0.001
    player.update(dt, input, nowSeconds)
    for each enemy: enemy.update(dt, player)
    for each enemy:
      enemy.onPlayerContact(player, this)
      enemy.checkDamageToPlayer(player, this)

  METHOD render():
    ctxRef = this.ctx
    w/h = current screen size
    renderBackdrop(ctxRef, w, h)
    ctx.save()
      translate(view.offsetX, view.offsetY)
      scale(view.scale)
      translate(shakeOffsetX, shakeOffsetY)
      renderPlayfield(ctx)
      renderGroundSplotches(ctx)
      nowSeconds = performance.now() * 0.001
      renderEntities(ctx, nowSeconds)
      renderParticles(ctx)
      renderFlashRings(ctx)
      renderTutorial(ctx)
      renderHealthBar(ctx)
    ctx.restore()

  METHOD renderBackdrop(ctx, w, h):
    clearRect full screen
    draw outer background #4a4a4a

  METHOD renderPlayfield(ctx):
    draw arena fill #8a8a8a
    draw border stroke #6a6a6a

  METHOD renderGroundSplotches(ctx):
    draw each splotch as alpha-tinted circle

  METHOD renderEntities(ctx, nowSeconds):
    holdDuration = input.getHoldDuration(nowSeconds)
    chargeVisible = input.down AND holdDuration >= input.chargeStartDelay
    chargeProgress = input.getChargeProgress(nowSeconds)
    draw all enemies
    draw player

  METHOD renderParticles(ctx):
    particles.draw(ctx)
    rainbowParticles.draw(ctx)

  METHOD renderFlashRings(ctx):
    for each ring:
      t = ring.age / ring.life
      radius = ring.maxRadius * easeOutCubic(t)
      alpha = 1 - t
      if ring.type == "shockwave":
        stroked white ring, shrinking line width
      else if "deathFlash":
        filled white disc

  METHOD renderTutorial(ctx):
    if tutorial exists: tutorial.draw(ctx)

  METHOD renderHealthBar(ctx):
    hbWidth = UI_CFG.healthBarWidth
    hbHeight = UI_CFG.healthBarHeight
    hbX centered horizontally
    hbY from bottom margin
    hpFrac = player.health / player.maxHealth
    draw black outer backing
    draw dark red empty bar
    draw bright red filled hp portion

  METHOD frame(timestamp):
    if first frame: lastTimestamp = timestamp
    frameDt = (timestamp-lastTimestamp)/1000
    lastTimestamp = timestamp
    frameDt = clamp(frameDt, 0, maxFrame)

    if tutorial active:
      tutorial.update(frameDt)

    if timeSlowTimer > 0:
      timeSlowTimer = max(0, timeSlowTimer-frameDt)
      elapsed = 1 - (timeSlowTimer/timeSlowDuration)
      timeScale = timeSlowMinScale + (1-timeSlowMinScale) * (elapsed^3)
    else:
      timeScale = 1

    holdDt = 0 if hitstop active else frameDt*timeScale
    input.advanceHold(holdDt)

    tutScale = tutorial.getTimeScale() if tutorial exists else 1
    accumulator += frameDt * timeScale * tutScale

    while accumulator >= fixedStep:
      update(fixedStep)
      accumulator -= fixedStep

    interpAlpha = 1 if fixedStep <= EPSILON else clamp(accumulator/fixedStep,0,1)
    for each enemy: enemy.interpolate(interpAlpha)

    render()
    requestAnimationFrame(frame)

  METHOD start():
    requestAnimationFrame(frame)


========================================================================
11) BOOTSTRAP
========================================================================

game = new Game(document.getElementById("gameCanvas"))
game.start()


========================================================================
12) UPDATE ORDER (PER FRAME)
========================================================================

For each RAF callback:
  1) Compute and clamp frameDt
  2) Tutorial update using real frameDt
  3) Update global timeScale from time slow curve
  4) Advance input hold timer (unless hitstop)
  5) Accumulate scaled dt
  6) Run zero or more fixed-step updates:
       - particles + ring aging + shake update
       - hitstop early-return gate
       - entities updates
       - combat interactions
  7) Interpolate enemy render transforms
  8) Render layers in deterministic order


========================================================================
13) GAMEPLAY RULE SUMMARY
========================================================================

Player:
  - swipe produces dodge unless hold-based charge threshold satisfied
  - charged attack has eased displacement profile
  - dodge movement is constant speed over short duration
  - movement constrained to playfield bounds

Enemy:
  - stalks player until trigger distance and cooldown permit windup
  - windup telegraphs, then charge dashes
  - recover decelerates and returns to stalk
  - charged player collisions apply damage + knockback + effects

Damage constraints:
  - same player action cannot hit same enemy repeatedly
  - dodge action never damages enemies
  - enemy only damages player during enemy charge overlap

Effects:
  - hit: particles + ring + shake + hitstop + time slow
  - death: stronger versions + rainbow burst
  - rainbow particles can stain player and floor at landing

Timing guarantees:
  - all timers/motion are dt-driven (seconds)
  - fixed-step simulation reduces frame variance artifacts
  - frame-rate independence is preserved across systems
BLEAK SWORD GIZMO PROTOTYPE
DETAILED PSEUDOCODE (CURRENT IMPLEMENTATION)

========================================================================
0) FILE SCOPE
========================================================================

Source file:
  - index.html (single-file game: HTML + CSS + JS)

Core characteristics:
  - one fullscreen canvas
  - fixed logical world: 500 x 720
  - pointer input: swipe for dodge / charged attack
  - player + multiple enemies (same enemy class)
  - particles, rainbow death particles, flash rings, stains/splotches
  - camera shake, hitstop, global time-slow, tutorial time scaling
  - fixed-step simulation with accumulator (frame-rate independent)


========================================================================
1) HTML + CSS
========================================================================

HTML:
  <canvas id="gameCanvas"></canvas>
  <script> entire runtime </script>

CSS:
  - disable text selection / touch callout globally
  - html/body fill viewport, overflow hidden
  - canvas fills viewport and disables browser touch gestures


========================================================================
2) GLOBAL CONSTANTS + CONFIGS
========================================================================

Primitive globals:
  GAME_WIDTH  = 500
  GAME_HEIGHT = 720
  TAU         = 2 * PI
  EPSILON     = 1e-7

Config groups:
  INPUT_CFG
    - swipe thresholds and charge timing

  PLAYER_CFG
    - dimensions, health, iframe/hit flash
    - dodge vs charged movement timings and travel distance
    - trail cadence/lifetime/alpha/cap
    - damping and hit shake values

  ENEMY_CFG
    - dimensions, state tuning, movement speeds
    - trail behavior, knockback/damping
    - combat reach and hit tuning

  FX_CFG
    - hit/death particle definitions
    - shockwave/death ring values
    - shake/hitstop/time-slow settings
    - rainbow burst count range

  UI_CFG
    - health bar dimensions and vertical offset


========================================================================
3) SHARED HELPERS
========================================================================

FUNCTION clamp(value, minValue, maxValue):
  return max(minValue, min(value, maxValue))

FUNCTION easeOutCubic(t):
  return 1 - (1 - t)^3

CLASS Vec2:
  add(a, b) -> {x, y}
  sub(a, b) -> {x, y}
  mul(v, s) -> {x, y}
  length(v) -> hypot(v.x, v.y)
  normalize(v):
    len = length(v)
    if len <= EPSILON: return {0, 0}
    return {v.x / len, v.y / len}

FUNCTION hslToRgb(h, s, l):
  convert HSL values to integer RGB values


========================================================================
4) INPUT SYSTEM
========================================================================

CLASS InputSystem(getWorldPointer):
  fields:
    getWorldPointer callback
    activePointerId
    down flag
    start/current pointer world positions
    holdGameDuration (accumulated with dt)
    pendingSwipe object or null
    minSwipeDistance, chargeStartDelay, chargeFillDuration,
    fullChargeThreshold, chargeGraceThreshold

  bind(canvas):
    register pointerdown/move/up/cancel listeners

  isInPlayfield(point):
    check bounds 0..GAME_WIDTH and 0..GAME_HEIGHT

  onPointerDown(event):
    ignore if already tracking pointer
    convert event to world
    ignore if invalid/outside playfield
    set down=true, store pointer id/start/current
    reset holdGameDuration and pendingSwipe

  onPointerMove(event):
    ignore if not active pointer
    update current world position

  onPointerUp(event):
    ignore if not active pointer
    releasePos = worldPos OR current
    swipeVec = releasePos - start
    swipeDistance = length(swipeVec)
    if swipeDistance >= minSwipeDistance:
      chargeAtRelease = normalized hold progress (0..1)
      pendingSwipe = {
        direction: normalize(swipeVec),
        distance,
        holdDuration,
        fullyCharged: chargeAtRelease >= chargeGraceThreshold
      }
    clear down + active pointer id

  advanceHold(dt):
    if down: holdGameDuration += dt

  consumeSwipe():
    out = pendingSwipe
    pendingSwipe = null
    return out

  getHoldDuration(nowSeconds):
    returns holdGameDuration when down, else 0

  getChargeProgress(nowSeconds):
    if hold < chargeStartDelay: return 0
    return clamp((hold - chargeStartDelay) / chargeFillDuration, 0, 1)


========================================================================
5) PLAYER
========================================================================

CLASS Player:
  state:
    position, velocity
    dimensions, baseAngle, spinAngle
    action {id,type,direction,duration,elapsed,travel,spins,startAngle,prevTravelT} or null
    actionSerial (increments per move)
    trail samples array + spawn timer
    stains array (colored splats drawn on body)
    health/maxHealth, iframe timers, hit flash timer

  startMove(type, direction):
    normalize direction
    choose dodge vs charged movement values from PLAYER_CFG
    create action object and increment actionSerial

  takeDamage(game):
    ignore if invulnerable/dead
    decrement health
    set iframes + hit flash
    trigger player-hit shake

  update(dt, input, nowSeconds):
    call in order:
      updateStatusTimers(dt)
      consumeQueuedSwipe(input)
      updateAction(dt)
      applyPostActionDamping(dt)
      applyMovement(dt)
      clampToPlayfield()
      ageTrail(dt)

  updateStatusTimers(dt):
    decay iframe and hit flash timers

  consumeQueuedSwipe(input):
    swipe = input.consumeSwipe()
    if swipe exists:
      startMove("charged" if swipe.fullyCharged else "dodge", swipe.direction)

  updateAction(dt):
    if no action: return
    cache frame start transform
    action.elapsed += dt
    t = clamp(elapsed / duration, 0, 1)

    if action.type == "charged":
      travelT = easeOutCubic(t)
      deltaTravel = (travelT - prevTravelT) * travel
      move player by deltaTravel along action direction
      set vx/vy from displacement / dt
    else:
      constant speed = travel / duration
      set vx/vy from direction * speed

    spinAngle = startAngle + spins * easeOutCubic(t)
    spawn trail samples at dodge/charged interval
      - interpolate sample position/angle inside current frame
      - skip near-duplicate samples
      - apply per-action life/alpha
      - cap trail size

    if elapsed >= duration:
      clear action
      set vx/vy = 0
      reset spinAngle

  applyPostActionDamping(dt):
    if no action:
      damp velocity by idleDampingRate
      spinAngle = 0

  applyMovement(dt):
    normal integration only when not in charged action
      (charged movement is already integrated in updateAction)

  clampToPlayfield():
    clamp x/y by player half extents

  ageTrail(dt):
    increment sample ages, remove expired samples

  draw(ctx, chargeProgress, chargeVisible):
    render trail
    if charged action active: render white ring around player
    render shadow ellipses
    blink skip on hit flash pulses
    render body outline + white body + stains clipped to body rect
    if charging and no action: render circular charge arc


========================================================================
6) TRIANGLE ENEMY (RAT EMOJI VISUAL)
========================================================================

CLASS TriangleEnemy(x, y):
  state:
    sim position and previous/render interpolation transforms
    movement velocity + knockback velocity
    dimensions/radius/health/alive
    entering flag (spawn from side then clamp x after entering bounds)
    AI state machine:
      "stalk" -> "windup" -> "charge" -> "recover" -> "stalk"
    timers: windup/charge/recover/postAttackCooldown, stun, hit cooldown/flash
    charge direction/spin data, waddle time
    trail samples + spawn timer
    lastHitByActionId (prevents repeated damage from same action)

  update(dt, player):
    if dead: return
    cachePreviousTransform()
    updateTimers(dt)
    ageTrail(dt)

    toPlayer = player - enemy
    playerDistance = length(toPlayer)
    toPlayerDir = normalized toPlayer (or zero vector)

    updateState(dt, playerDistance, toPlayerDir)
    applyKnockbackDamping(dt)
    integratePosition(dt)
    clampToPlayfield()

  updateState(...):
    if stunned: zero vx/vy and roll angle, return
    dispatch to state handlers:
      updateStalkState
      updateWindupState
      updateChargeState
      updateRecoverState

  updateStalkState:
    move toward player at stalkSpeed
    if close enough and cooldown finished:
      enter windup
      lock chargeDirection (fallback to default up direction if degenerate)
      stop movement

  updateWindupState:
    hold still and count down windup
    when done:
      enter charge
      reset charge timer/elapsed
      set spin direction from chargeDirection.x sign

  updateChargeState:
    set velocity = chargeDirection * chargeSpeed
    advance chargeElapsed -> rollAngle via easeOutCubic
    spawn charge trail samples
    when charge ends:
      enter recover
      set recover timer and post-attack cooldown

  updateRecoverState:
    damp velocity, zero roll angle
    when timer ends -> return to stalk

  isOverlappingPlayer(player):
    reach = max(player.w, player.h) * combatReachFactor + hitRadius
    return squared distance <= reach^2

  onPlayerContact(player, game):
    if canReceiveChargedHit(player) == false: return
    away = getAwayFromHitDirection(player)
    applyChargedHit(player, away)
    hit point = midpoint(player/enemy)
    spawnChargedHitEffects(game, hit point, away)
    if health <= 0: handleDeath(game)

  canReceiveChargedHit(player):
    requires:
      - enemy alive
      - player has action
      - overlap
      - action type is charged (not dodge)
      - hit cooldown <= 0
      - this action id has not already hit this enemy

  applyChargedHit:
    decrement health
    store action id
    set hit flash / hit cooldown / stun
    force recover state and timer
    apply knockback impulse

  spawnChargedHitEffects:
    emit directional hit particles
    add shockwave ring
    trigger shake + hitstop + time-slow

  handleDeath:
    alive = false
    trigger stronger shake/hitstop/time-slow
    add death flash ring
    emit death particles
    emit rainbow burst particles

  checkDamageToPlayer(player, game):
    only during enemy charge
    skip if player invulnerable/dead/dodging/not overlapping
    call player.takeDamage(game)

  interpolate(alpha):
    lerp render transform from previous sim transform

  draw(ctx, nowSeconds):
    if dead: return
    draw trail
    draw shadows
    compute waddle in stalk/recover
    apply hit/windup flashing alpha effects
    draw rat emoji at interpolated transform


========================================================================
7) PARTICLE SYSTEMS
========================================================================

CLASS ParticleSystem:
  particles = []

  emit(x, y, count, config):
    create count particles with random angle/speed/life/size/color in config ranges

  update(dt):
    apply optional drag damping
    integrate position
    decrement life
    remove dead particles

  draw(ctx):
    render each particle as velocity-aligned rectangle
    alpha and size decay with normalized remaining life


CLASS RainbowDeathParticleSystem:
  particles = []

  emit(x, y, count):
    generate colorful 3D-ish particles:
      - random direction/speed
      - z and vz for arc behavior
      - gravity, drag, bounciness
      - random HSL color converted to RGB

  update(dt, player, groundSplotches):
    for each particle:
      apply gravity and drag
      integrate x/y/z
      bounce against world bounds in x/y

      if particle reaches "ground" (z <= 0 while falling):
        compute player rect
        compute direct hit or splash overlap
        if player hit/splash:
          add stain to player local coordinates
        if not direct hit:
          add colored ground splotch
        remove particle

  draw(ctx):
    render as colored circles
    visualY offset by z and size scales with z


========================================================================
8) TUTORIAL FLOW
========================================================================

CLASS Tutorial(game):
  fields:
    phase, phaseTime, fingerAnimTime, textAlpha, active
    tutorialTimeScale (multiplies game sim speed)
    attackDir (hint direction)
    slow-motion tuning and chain spawn controls

  phases:
    intro
    waitDodge
    dodging
    postDodgeWait
    waitHold
    waitAttack
    attacking
    chainSpawns
    done

  setPhase(newPhase):
    assign phase and reset per-phase timers/alpha

  update(realDt):
    if inactive: return
    advance phase timers
    switch by phase:
      intro:
        wait for enemy charge progress threshold then go waitDodge
      waitDodge:
        lower tutorialTimeScale toward crawl/stop
        fade in prompt
        on swipe -> force player dodge, restore time, go dodging
      dodging:
        clear queued swipes, fade out text, wait for action end
      postDodgeWait:
        short delay then go waitHold
      waitHold:
        lower tutorialTimeScale toward crawl/stop
        clear swipes
        wait until charge progress full, lock attackDir toward nearest alive enemy
      waitAttack:
        pause gameplay (tutorialTimeScale=0)
        on swipe -> force charged attack and go attacking
      attacking:
        fade text out
        if base enemy dies: initialize chain spawn wave and go chainSpawns
        else if attack complete for a while: tutorial done
      chainSpawns:
        spawn enemies from random horizontal sides with delay
        when all enemies dead -> done

  getTimeScale():
    return tutorialTimeScale if active else 1

  spawnEnemyFromRandomHorizontalSide():
    create new TriangleEnemy just outside left or right bound
    initialize runtime fields for entering behavior and reduced health
    push into game.enemies

  draw(ctx):
    render contextual overlays + text + swipe/hold indicators
    only during waitDodge / waitHold / waitAttack


========================================================================
9) GAME ORCHESTRATION
========================================================================

CLASS Game(canvas):
  fields:
    canvas/context
    viewport transform (scale + offsets)
    screen size cache
    input, player, base enemy, enemies array
    timing: lastTimestamp, accumulator, fixedStep(1/120), maxFrame
    effects state: shake, hitstop, global time slow
    systems: particles, rainbowParticles, flashRings, groundSplotches
    tutorial instance

  constructor:
    initialize all systems
    seed one enemy already in charge state for tutorial opener
    bind resize handler
    call resize()

  resize():
    compute DPR-backed canvas size
    set canvas transform for DPR
    compute world-to-screen scale preserving aspect
    compute centered offsets

  eventToWorld(event):
    convert client pointer coordinates into game-world coordinates

  triggerShake / triggerHitstop / triggerTimeSlow:
    update effect timers/intensity parameters

  getClosestAliveEnemy(fromEntity):
    linear search by smallest squared distance

  update(dt):
    update particles and rainbow particles
    age/prune flash rings
    update shake offsets while shake timer active

    if hitstop active:
      decrement hitstop and return early

    nowSeconds = performance.now() * 0.001
    update player
    update each enemy
    process enemy-player interactions (enemy takes damage / player takes damage)

  render():
    renderBackdrop()
    push world transform (offset + scale + shake)
    renderPlayfield()
    renderGroundSplotches()
    renderEntities(nowSeconds)
    renderParticles()
    renderFlashRings()
    renderTutorial()
    renderHealthBar()
    pop world transform

  renderBackdrop(ctx, w, h):
    clear screen and draw outer background

  renderPlayfield(ctx):
    draw inner arena panel and border

  renderGroundSplotches(ctx):
    draw static colored splats on floor

  renderEntities(ctx, nowSeconds):
    query input hold/charge state
    draw enemies then player

  renderParticles(ctx):
    draw normal particles then rainbow particles

  renderFlashRings(ctx):
    for each ring:
      t = age / life
      radius = maxRadius * easeOutCubic(t)
      alpha = 1 - t
      type shockwave -> stroked ring
      type deathFlash -> filled circle

  renderTutorial(ctx):
    delegate tutorial overlay draw if tutorial exists

  renderHealthBar(ctx):
    draw backing, empty bar, and filled hp fraction

  frame(timestamp):
    initialize timestamp on first frame
    frameDt = clamp((timestamp - lastTimestamp)/1000, 0, maxFrame)
    update lastTimestamp

    if tutorial active: tutorial.update(frameDt)

    update global timeScale from cubic recovery while timeSlow active

    holdDt = (hitstop active) ? 0 : frameDt * timeScale
    input.advanceHold(holdDt)

    tutScale = tutorial.getTimeScale() or 1
    accumulator += frameDt * timeScale * tutScale

    while accumulator >= fixedStep:
      update(fixedStep)
      accumulator -= fixedStep

    interpAlpha = clamp(accumulator / fixedStep, 0, 1) (safe fallback)
    for each enemy: enemy.interpolate(interpAlpha)

    render()
    requestAnimationFrame(frame)

  start():
    requestAnimationFrame(frame)


========================================================================
10) BOOTSTRAP
========================================================================

game = new Game(document.getElementById("gameCanvas"))
game.start()


========================================================================
11) GAMEPLAY + TIMING SUMMARY
========================================================================

Player actions:
  - swipe after short/no hold -> dodge
  - hold then swipe with enough charge -> charged attack

Combat:
  - charged action damages enemies on overlap
  - dodge avoids damage and does not damage enemies
  - enemy deals damage to player only during enemy charge overlap

Feedback:
  - trails, flashes, particles, flash rings
  - hitstop + camera shake + temporary time slow
  - rainbow splats stain player and floor on enemy death

Timing model:
  - all simulation uses dt (seconds), not frame count
  - fixed-step update loop for consistency
  - frame delta clamped for stability
  - tutorial and time-slow scale simulation without frame dependence
