BLEAK SWORD GIZMO PROTOTYPE
DETAILED PSEUDOCODE (CURRENT IMPLEMENTATION)

========================================================================
0) FILE SCOPE
========================================================================

Source file:
  - index.html (single-file game: HTML + CSS + JS)

Core characteristics:
  - one fullscreen canvas
  - fixed logical world: 500 x 720
  - pointer input: swipe for dodge / charged attack
  - player + multiple enemies (same enemy class)
  - particles, rainbow death particles, flash rings, stains/splotches
  - camera shake, hitstop, global time-slow, tutorial time scaling
  - fixed-step simulation with accumulator (frame-rate independent)


========================================================================
1) HTML + CSS
========================================================================

HTML:
  <canvas id="gameCanvas"></canvas>
  <script> entire runtime </script>

CSS:
  - disable text selection / touch callout globally
  - html/body fill viewport, overflow hidden
  - canvas fills viewport and disables browser touch gestures


========================================================================
2) GLOBAL CONSTANTS + CONFIGS
========================================================================

Primitive globals:
  GAME_WIDTH  = 500
  GAME_HEIGHT = 720
  TAU         = 2 * PI
  EPSILON     = 1e-7

Config groups:
  INPUT_CFG
    - swipe thresholds and charge timing

  PLAYER_CFG
    - dimensions, health, iframe/hit flash
    - dodge vs charged movement timings and travel distance
    - trail cadence/lifetime/alpha/cap
    - damping and hit shake values

  ENEMY_CFG
    - dimensions, state tuning, movement speeds
    - trail behavior, knockback/damping
    - combat reach and hit tuning

  FX_CFG
    - hit/death particle definitions
    - shockwave/death ring values
    - shake/hitstop/time-slow settings
    - rainbow burst count range

  UI_CFG
    - health bar dimensions and vertical offset


========================================================================
3) SHARED HELPERS
========================================================================

FUNCTION clamp(value, minValue, maxValue):
  return max(minValue, min(value, maxValue))

FUNCTION easeOutCubic(t):
  return 1 - (1 - t)^3

CLASS Vec2:
  add(a, b) -> {x, y}
  sub(a, b) -> {x, y}
  mul(v, s) -> {x, y}
  length(v) -> hypot(v.x, v.y)
  normalize(v):
    len = length(v)
    if len <= EPSILON: return {0, 0}
    return {v.x / len, v.y / len}

FUNCTION hslToRgb(h, s, l):
  convert HSL values to integer RGB values


========================================================================
4) INPUT SYSTEM
========================================================================

CLASS InputSystem(getWorldPointer):
  fields:
    getWorldPointer callback
    activePointerId
    down flag
    start/current pointer world positions
    holdGameDuration (accumulated with dt)
    pendingSwipe object or null
    minSwipeDistance, chargeStartDelay, chargeFillDuration,
    fullChargeThreshold, chargeGraceThreshold

  bind(canvas):
    register pointerdown/move/up/cancel listeners

  isInPlayfield(point):
    check bounds 0..GAME_WIDTH and 0..GAME_HEIGHT

  onPointerDown(event):
    ignore if already tracking pointer
    convert event to world
    ignore if invalid/outside playfield
    set down=true, store pointer id/start/current
    reset holdGameDuration and pendingSwipe

  onPointerMove(event):
    ignore if not active pointer
    update current world position

  onPointerUp(event):
    ignore if not active pointer
    releasePos = worldPos OR current
    swipeVec = releasePos - start
    swipeDistance = length(swipeVec)
    if swipeDistance >= minSwipeDistance:
      chargeAtRelease = normalized hold progress (0..1)
      pendingSwipe = {
        direction: normalize(swipeVec),
        distance,
        holdDuration,
        fullyCharged: chargeAtRelease >= chargeGraceThreshold
      }
    clear down + active pointer id

  advanceHold(dt):
    if down: holdGameDuration += dt

  consumeSwipe():
    out = pendingSwipe
    pendingSwipe = null
    return out

  getHoldDuration(nowSeconds):
    returns holdGameDuration when down, else 0

  getChargeProgress(nowSeconds):
    if hold < chargeStartDelay: return 0
    return clamp((hold - chargeStartDelay) / chargeFillDuration, 0, 1)


========================================================================
5) PLAYER
========================================================================

CLASS Player:
  state:
    position, velocity
    dimensions, baseAngle, spinAngle
    action {id,type,direction,duration,elapsed,travel,spins,startAngle,prevTravelT} or null
    actionSerial (increments per move)
    trail samples array + spawn timer
    stains array (colored splats drawn on body)
    health/maxHealth, iframe timers, hit flash timer

  startMove(type, direction):
    normalize direction
    choose dodge vs charged movement values from PLAYER_CFG
    create action object and increment actionSerial

  takeDamage(game):
    ignore if invulnerable/dead
    decrement health
    set iframes + hit flash
    trigger player-hit shake

  update(dt, input, nowSeconds):
    call in order:
      updateStatusTimers(dt)
      consumeQueuedSwipe(input)
      updateAction(dt)
      applyPostActionDamping(dt)
      applyMovement(dt)
      clampToPlayfield()
      ageTrail(dt)

  updateStatusTimers(dt):
    decay iframe and hit flash timers

  consumeQueuedSwipe(input):
    swipe = input.consumeSwipe()
    if swipe exists:
      startMove("charged" if swipe.fullyCharged else "dodge", swipe.direction)

  updateAction(dt):
    if no action: return
    cache frame start transform
    action.elapsed += dt
    t = clamp(elapsed / duration, 0, 1)

    if action.type == "charged":
      travelT = easeOutCubic(t)
      deltaTravel = (travelT - prevTravelT) * travel
      move player by deltaTravel along action direction
      set vx/vy from displacement / dt
    else:
      constant speed = travel / duration
      set vx/vy from direction * speed

    spinAngle = startAngle + spins * easeOutCubic(t)
    spawn trail samples at dodge/charged interval
      - interpolate sample position/angle inside current frame
      - skip near-duplicate samples
      - apply per-action life/alpha
      - cap trail size

    if elapsed >= duration:
      clear action
      set vx/vy = 0
      reset spinAngle

  applyPostActionDamping(dt):
    if no action:
      damp velocity by idleDampingRate
      spinAngle = 0

  applyMovement(dt):
    normal integration only when not in charged action
      (charged movement is already integrated in updateAction)

  clampToPlayfield():
    clamp x/y by player half extents

  ageTrail(dt):
    increment sample ages, remove expired samples

  draw(ctx, chargeProgress, chargeVisible):
    render trail
    if charged action active: render white ring around player
    render shadow ellipses
    blink skip on hit flash pulses
    render body outline + white body + stains clipped to body rect
    if charging and no action: render circular charge arc


========================================================================
6) TRIANGLE ENEMY (RAT EMOJI VISUAL)
========================================================================

CLASS TriangleEnemy(x, y):
  state:
    sim position and previous/render interpolation transforms
    movement velocity + knockback velocity
    dimensions/radius/health/alive
    entering flag (spawn from side then clamp x after entering bounds)
    AI state machine:
      "stalk" -> "windup" -> "charge" -> "recover" -> "stalk"
    timers: windup/charge/recover/postAttackCooldown, stun, hit cooldown/flash
    charge direction/spin data, waddle time
    trail samples + spawn timer
    lastHitByActionId (prevents repeated damage from same action)

  update(dt, player):
    if dead: return
    cachePreviousTransform()
    updateTimers(dt)
    ageTrail(dt)

    toPlayer = player - enemy
    playerDistance = length(toPlayer)
    toPlayerDir = normalized toPlayer (or zero vector)

    updateState(dt, playerDistance, toPlayerDir)
    applyKnockbackDamping(dt)
    integratePosition(dt)
    clampToPlayfield()

  updateState(...):
    if stunned: zero vx/vy and roll angle, return
    dispatch to state handlers:
      updateStalkState
      updateWindupState
      updateChargeState
      updateRecoverState

  updateStalkState:
    move toward player at stalkSpeed
    if close enough and cooldown finished:
      enter windup
      lock chargeDirection (fallback to default up direction if degenerate)
      stop movement

  updateWindupState:
    hold still and count down windup
    when done:
      enter charge
      reset charge timer/elapsed
      set spin direction from chargeDirection.x sign

  updateChargeState:
    set velocity = chargeDirection * chargeSpeed
    advance chargeElapsed -> rollAngle via easeOutCubic
    spawn charge trail samples
    when charge ends:
      enter recover
      set recover timer and post-attack cooldown

  updateRecoverState:
    damp velocity, zero roll angle
    when timer ends -> return to stalk

  isOverlappingPlayer(player):
    reach = max(player.w, player.h) * combatReachFactor + hitRadius
    return squared distance <= reach^2

  onPlayerContact(player, game):
    if canReceiveChargedHit(player) == false: return
    away = getAwayFromHitDirection(player)
    applyChargedHit(player, away)
    hit point = midpoint(player/enemy)
    spawnChargedHitEffects(game, hit point, away)
    if health <= 0: handleDeath(game)

  canReceiveChargedHit(player):
    requires:
      - enemy alive
      - player has action
      - overlap
      - action type is charged (not dodge)
      - hit cooldown <= 0
      - this action id has not already hit this enemy

  applyChargedHit:
    decrement health
    store action id
    set hit flash / hit cooldown / stun
    force recover state and timer
    apply knockback impulse

  spawnChargedHitEffects:
    emit directional hit particles
    add shockwave ring
    trigger shake + hitstop + time-slow

  handleDeath:
    alive = false
    trigger stronger shake/hitstop/time-slow
    add death flash ring
    emit death particles
    emit rainbow burst particles

  checkDamageToPlayer(player, game):
    only during enemy charge
    skip if player invulnerable/dead/dodging/not overlapping
    call player.takeDamage(game)

  interpolate(alpha):
    lerp render transform from previous sim transform

  draw(ctx, nowSeconds):
    if dead: return
    draw trail
    draw shadows
    compute waddle in stalk/recover
    apply hit/windup flashing alpha effects
    draw rat emoji at interpolated transform


========================================================================
7) PARTICLE SYSTEMS
========================================================================

CLASS ParticleSystem:
  particles = []

  emit(x, y, count, config):
    create count particles with random angle/speed/life/size/color in config ranges

  update(dt):
    apply optional drag damping
    integrate position
    decrement life
    remove dead particles

  draw(ctx):
    render each particle as velocity-aligned rectangle
    alpha and size decay with normalized remaining life


CLASS RainbowDeathParticleSystem:
  particles = []

  emit(x, y, count):
    generate colorful 3D-ish particles:
      - random direction/speed
      - z and vz for arc behavior
      - gravity, drag, bounciness
      - random HSL color converted to RGB

  update(dt, player, groundSplotches):
    for each particle:
      apply gravity and drag
      integrate x/y/z
      bounce against world bounds in x/y

      if particle reaches "ground" (z <= 0 while falling):
        compute player rect
        compute direct hit or splash overlap
        if player hit/splash:
          add stain to player local coordinates
        if not direct hit:
          add colored ground splotch
        remove particle

  draw(ctx):
    render as colored circles
    visualY offset by z and size scales with z


========================================================================
8) TUTORIAL FLOW
========================================================================

CLASS Tutorial(game):
  fields:
    phase, phaseTime, fingerAnimTime, textAlpha, active
    tutorialTimeScale (multiplies game sim speed)
    attackDir (hint direction)
    slow-motion tuning and chain spawn controls

  phases:
    intro
    waitDodge
    dodging
    postDodgeWait
    waitHold
    waitAttack
    attacking
    chainSpawns
    done

  setPhase(newPhase):
    assign phase and reset per-phase timers/alpha

  update(realDt):
    if inactive: return
    advance phase timers
    switch by phase:
      intro:
        wait for enemy charge progress threshold then go waitDodge
      waitDodge:
        lower tutorialTimeScale toward crawl/stop
        fade in prompt
        on swipe -> force player dodge, restore time, go dodging
      dodging:
        clear queued swipes, fade out text, wait for action end
      postDodgeWait:
        short delay then go waitHold
      waitHold:
        lower tutorialTimeScale toward crawl/stop
        clear swipes
        wait until charge progress full, lock attackDir toward nearest alive enemy
      waitAttack:
        pause gameplay (tutorialTimeScale=0)
        on swipe -> force charged attack and go attacking
      attacking:
        fade text out
        if base enemy dies: initialize chain spawn wave and go chainSpawns
        else if attack complete for a while: tutorial done
      chainSpawns:
        spawn enemies from random horizontal sides with delay
        when all enemies dead -> done

  getTimeScale():
    return tutorialTimeScale if active else 1

  spawnEnemyFromRandomHorizontalSide():
    create new TriangleEnemy just outside left or right bound
    initialize runtime fields for entering behavior and reduced health
    push into game.enemies

  draw(ctx):
    render contextual overlays + text + swipe/hold indicators
    only during waitDodge / waitHold / waitAttack


========================================================================
9) GAME ORCHESTRATION
========================================================================

CLASS Game(canvas):
  fields:
    canvas/context
    viewport transform (scale + offsets)
    screen size cache
    input, player, base enemy, enemies array
    timing: lastTimestamp, accumulator, fixedStep(1/120), maxFrame
    effects state: shake, hitstop, global time slow
    systems: particles, rainbowParticles, flashRings, groundSplotches
    tutorial instance

  constructor:
    initialize all systems
    seed one enemy already in charge state for tutorial opener
    bind resize handler
    call resize()

  resize():
    compute DPR-backed canvas size
    set canvas transform for DPR
    compute world-to-screen scale preserving aspect
    compute centered offsets

  eventToWorld(event):
    convert client pointer coordinates into game-world coordinates

  triggerShake / triggerHitstop / triggerTimeSlow:
    update effect timers/intensity parameters

  getClosestAliveEnemy(fromEntity):
    linear search by smallest squared distance

  update(dt):
    update particles and rainbow particles
    age/prune flash rings
    update shake offsets while shake timer active

    if hitstop active:
      decrement hitstop and return early

    nowSeconds = performance.now() * 0.001
    update player
    update each enemy
    process enemy-player interactions (enemy takes damage / player takes damage)

  render():
    renderBackdrop()
    push world transform (offset + scale + shake)
    renderPlayfield()
    renderGroundSplotches()
    renderEntities(nowSeconds)
    renderParticles()
    renderFlashRings()
    renderTutorial()
    renderHealthBar()
    pop world transform

  renderBackdrop(ctx, w, h):
    clear screen and draw outer background

  renderPlayfield(ctx):
    draw inner arena panel and border

  renderGroundSplotches(ctx):
    draw static colored splats on floor

  renderEntities(ctx, nowSeconds):
    query input hold/charge state
    draw enemies then player

  renderParticles(ctx):
    draw normal particles then rainbow particles

  renderFlashRings(ctx):
    for each ring:
      t = age / life
      radius = maxRadius * easeOutCubic(t)
      alpha = 1 - t
      type shockwave -> stroked ring
      type deathFlash -> filled circle

  renderTutorial(ctx):
    delegate tutorial overlay draw if tutorial exists

  renderHealthBar(ctx):
    draw backing, empty bar, and filled hp fraction

  frame(timestamp):
    initialize timestamp on first frame
    frameDt = clamp((timestamp - lastTimestamp)/1000, 0, maxFrame)
    update lastTimestamp

    if tutorial active: tutorial.update(frameDt)

    update global timeScale from cubic recovery while timeSlow active

    holdDt = (hitstop active) ? 0 : frameDt * timeScale
    input.advanceHold(holdDt)

    tutScale = tutorial.getTimeScale() or 1
    accumulator += frameDt * timeScale * tutScale

    while accumulator >= fixedStep:
      update(fixedStep)
      accumulator -= fixedStep

    interpAlpha = clamp(accumulator / fixedStep, 0, 1) (safe fallback)
    for each enemy: enemy.interpolate(interpAlpha)

    render()
    requestAnimationFrame(frame)

  start():
    requestAnimationFrame(frame)


========================================================================
10) BOOTSTRAP
========================================================================

game = new Game(document.getElementById("gameCanvas"))
game.start()


========================================================================
11) GAMEPLAY + TIMING SUMMARY
========================================================================

Player actions:
  - swipe after short/no hold -> dodge
  - hold then swipe with enough charge -> charged attack

Combat:
  - charged action damages enemies on overlap
  - dodge avoids damage and does not damage enemies
  - enemy deals damage to player only during enemy charge overlap

Feedback:
  - trails, flashes, particles, flash rings
  - hitstop + camera shake + temporary time slow
  - rainbow splats stain player and floor on enemy death

Timing model:
  - all simulation uses dt (seconds), not frame count
  - fixed-step update loop for consistency
  - frame delta clamped for stability
  - tutorial and time-slow scale simulation without frame dependence
